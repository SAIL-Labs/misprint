
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>misprint</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-03-16"><meta name="DC.source" content="misprint.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#3">parse inputs</a></li><li><a href="#4">start matlabpool if parallel computing tool box avaliable</a></li><li><a href="#5">root path</a></li><li><a href="#6">main reduction target path construction</a></li><li><a href="#7">reference target path construction</a></li><li><a href="#8">1D spectra filenames</a></li><li><a href="#9">check for required cards in fits header and read the values. add defaults where unavaliable.</a></li><li><a href="#10">load misprint, and orientate so echelle dispersion is horizontal</a></li><li><a href="#11">trace col</a></li><li><a href="#12">load wavelength solution if supplied</a></li><li><a href="#15">inital setup</a></li><li><a href="#16">load data into local variables</a></li><li><a href="#17">find orders</a></li><li><a href="#18">trace orders</a></li><li><a href="#25">scattered light estimate</a></li></ul></div><pre class="codeinput"><span class="keyword">classdef</span> misprint &lt; handleAllHidden
    <span class="comment">%MISPRINT MultIorder SPectroscopic ReductIoN Tool</span>
    <span class="comment">%</span>
    <span class="comment">% Properties are set using key value pairs.</span>
    <span class="comment">%</span>
    <span class="comment">% Sample Usage:</span>
    <span class="comment">%     s2r = misprint('sciencespectrum','reference','flatspectrum','plotAlot',true,...</span>
    <span class="comment">%         'usecurrentfolderonly',true,...</span>
    <span class="comment">%         'numOfOrders',14,'numOfFibers',29,...</span>
    <span class="comment">%         'forceTrace',false,'forceExtract',false,...</span>
    <span class="comment">%         'forceDefineMaskEdge',false,'needsMask',false,...</span>
    <span class="comment">%         'peakcut',0.07,'minPeakSeperation',3,...</span>
    <span class="comment">%         'numTraceCol',40,'firstCol',140,'lastCol',300,...</span>
    <span class="comment">%         'parallel',false);</span>
    <span class="comment">%</span>
    <span class="comment">%     self.getMaskForIncompleteOrders;</span>
    <span class="comment">%     self.traceSpectra;</span>
    <span class="comment">%     self.extractSpectra;</span>
    <span class="comment">%     self.getP2PVariationsAndBlaze(false);</span>
    <span class="comment">%</span>
    <span class="comment">%     self.plotSpectraFor(1:14,true,false)</span>
    <span class="comment">%</span>
    <span class="comment">% Copyright (C) Chris Betters 2012-2014</span>

    <span class="keyword">properties</span>
        targetBaseFilename, <span class="comment">% base filename of target (file with spectra to be extracted) fits file.</span>
        targetPath, <span class="comment">% path to target fits file.</span>
        rootDirectory, <span class="comment">% path to current directory, should equal [pwd '/'].</span>
        referenceBaseFilename, <span class="comment">% base filename of reference fits file (i.e. a flat frame).</span>
        referencePath, <span class="comment">% path to reference fits file.</span>

        targetHeader, <span class="comment">% structure with target fits header.</span>
        referenceHeader, <span class="comment">% structure with reference fits header.</span>

        SpectraFitsSaveFileName, <span class="comment">% filename of fits file to save extracted spectra to.</span>
        ReferenceSpectraFitsSaveFileName, <span class="comment">% spectra previously extracted from the reference fits file.</span>
        FlatReferenceSpectraFitsSaveFileName, <span class="comment">% filename of fits file to for use as a flat reference, should be just pixel to pixel variations.</span>

        spectraTracePath, <span class="comment">% path to previously saved trace data for reference fits file.</span>

        useReference, <span class="comment">% flag to indicate if valid reference data has been set/ffound.</span>
        plotAlot, <span class="comment">% flag to show raw image and plots during tracing. It can plot alot.</span>
        forceTrace, <span class="comment">% flag to force a trace of spectra in the current image. Can not be set with a reference.</span>
        forceExtract, <span class="comment">% flag to force a new extraction of the current image. This will overwrite the default save file if it exists.</span>
        forceDefineMaskEdge, <span class="comment">% flag to force a new definition of the mask/clipping region.</span>
        needsMask, <span class="comment">% flag to indicate if image requires clipping.</span>
        clipping, <span class="comment">% vector of pixels from [left top right bottom] to clip.</span>
        parallel, <span class="comment">% flag tin indicate if parallel compuyting toolbox should/can be used.</span>
        minPeakSeperation, <span class="comment">% min peak seperation for tracing and peakfinder</span>

        numOfOrders, <span class="comment">% number of diffraction orders in image.</span>
        numOfFibers, <span class="comment">% number of spectra (fibres) in each order.</span>

        gain, <span class="comment">% gain (e-/adu) read from fits file</span>
        readNoise, <span class="comment">% read noise (rms e-) read from fits file</span>
        dispAxis, <span class="comment">% axis of primary dispersion read from fits file</span>

        imdata, <span class="comment">% target image data.</span>
        imvariance, <span class="comment">% estiamted variance for target image data.</span>
        mask, <span class="comment">% mask of clipped regions.</span>
        imdim, <span class="comment">% size of imdata (equals size(imdata))</span>

        spectraValues, <span class="comment">% extracted spectra values.</span>
        spectraVar, <span class="comment">% var for extracted spec values.</span>
        backgroundValues, <span class="comment">% background value from extraction</span>

        finalSpectra, <span class="comment">%  linearised version of complete spectrum for individual fibre (all orders)</span>
        finalSpec, <span class="comment">% linearised combined spectrum</span>
        finalSpectraVar, <span class="comment">% varience for finalSpectra</span>
        finalSpecVar, <span class="comment">% varience for finalSpec</span>
        finalWave, <span class="comment">% linearised wavelength scale for finalSpectra and finalSpec</span>

        referenceSpectraValues, <span class="comment">% extracted spectraValues of reference/flat</span>
        P2PVariationValues, <span class="comment">% pixel to pixel variation from reference.</span>
        flatBlaze, <span class="comment">% estimated blaze from reference.</span>

        wavematfile, <span class="comment">% mat file with wavelength fit paramaters</span>
        wavefit,<span class="comment">% wavelength soultion for each fibre</span>
        diffractionOrder, <span class="comment">% estimated diffraction order from wavefit</span>

        numTraceCol, <span class="comment">% number of columns to use when tracing.</span>
        firstCol, <span class="comment">% first column of trace</span>
        lastCol, <span class="comment">% last column of trace</span>

        orderEdges,  <span class="comment">% detected edges of the orders</span>
        specCenters, <span class="comment">% polynoimail interpolated fitted y axis centeres of the spectra from gaussain fit.</span>
        specWidth,   <span class="comment">% polynomial interpolated width of the spectra from gaussain fit.</span>
        meanSpecWidth, <span class="comment">% mean width of spceetra in each order.</span>
        meanOrderWidth, <span class="comment">% mean width of each order</span>

        fittedCenters, <span class="comment">% center of spectrum (vertical) from gaussian fit</span>
        fittedCol, <span class="comment">% column used to get progile for fit</span>
        fittedWidth, <span class="comment">% width of specturm (vertical) from gaussain fit</span>
        fittedParamters, <span class="comment">% all fit paramaters from trace</span>

        usecurrentfolderonly, <span class="comment">% flag to note use my maxiumDL/PIMMS echelle file structure.</span>
        peakcut, <span class="comment">% MINPEAKHEIGHT for spectra tracing detection. (fraction of mean of current profile).</span>

        OXmethod, <span class="comment">% name of method to use for optimal extraction.</span>
    <span class="keyword">end</span>

    <span class="keyword">methods</span>
        <span class="keyword">function</span> self=misprint(targetBaseFilename,varargin)
</pre><pre class="codeinput">            <span class="comment">% init the MISPRINT class. Pasre all inputs, load relevant files.</span>
</pre><h2>parse inputs<a name="3"></a></h2><pre class="codeinput">            p = inputParser;

            p.addRequired(<span class="string">'targetBaseFilename'</span>, @(x) ischar(x));
            p.addParamValue(<span class="string">'reference'</span>,<span class="string">''</span>);
            p.addParamValue(<span class="string">'forceTrace'</span>            , false, @(x) islogical(x));
            p.addParamValue(<span class="string">'forceExtract'</span>          , false, @(x) islogical(x));
            p.addParamValue(<span class="string">'plotAlot'</span>      , false, @(x) islogical(x));
            p.addParamValue(<span class="string">'forceDefineMaskEdge'</span>, false, @(x) islogical(x));
            p.addParamValue(<span class="string">'needsMask'</span>, true, @(x) islogical(x));
            p.addParamValue(<span class="string">'numOfOrders'</span>, 15, @(x) isnumeric(x));
            p.addParamValue(<span class="string">'numOfFibers'</span>, 19, @(x) isnumeric(x));
            p.addParamValue(<span class="string">'usecurrentfolderonly'</span>,false, @(x) islogical(x));
            p.addParamValue(<span class="string">'peakcut'</span>, 0.8, @(x) isnumeric(x));
            p.addParamValue(<span class="string">'parallel'</span>,true, @(x) islogical(x));
            p.addParamValue(<span class="string">'numTraceCol'</span>, 10, @(x) isnumeric(x));
            p.addParamValue(<span class="string">'dispAxis'</span>, [], @(x) isnumeric(x));
            p.addParamValue(<span class="string">'wavesolution'</span>, <span class="string">''</span>, @(x) ischar(x));
            p.addParamValue(<span class="string">'minPeakSeperation'</span>, 3, @(x) isnumeric(x));
            p.addParamValue(<span class="string">'firstCol'</span>, 0, @(x) isnumeric(x));
            p.addParamValue(<span class="string">'lastCol'</span>, 0, @(x) isnumeric(x));
            p.addParamValue(<span class="string">'clipping'</span>,[0 0 0 0], @(x) isnumeric(x) &amp;&amp; length(x)==4)
            p.addParamValue(<span class="string">'OXmethod'</span>,<span class="string">'MPDoptimalExtBack'</span>, @(x) ismethod(self,x))

            p.parse(targetBaseFilename,varargin{:});

            self.numOfOrders=p.Results.numOfOrders;
            self.numOfFibers=p.Results.numOfFibers;
            self.forceExtract=p.Results.forceExtract;
            self.forceTrace=p.Results.forceTrace;
            self.plotAlot=p.Results.plotAlot;
            self.forceDefineMaskEdge=p.Results.forceDefineMaskEdge;
            self.needsMask=p.Results.needsMask;

            self.usecurrentfolderonly=p.Results.usecurrentfolderonly;
            self.peakcut=p.Results.peakcut;

            self.parallel=p.Results.parallel;
            self.numTraceCol=p.Results.numTraceCol;
            self.firstCol=p.Results.firstCol; <span class="comment">%if zero set to 20 minus miage size (at end)</span>
            self.lastCol=p.Results.lastCol; <span class="comment">%if zero set to 20 minus miage size (at end of init)</span>

            self.dispAxis=p.Results.dispAxis;

            self.minPeakSeperation=p.Results.minPeakSeperation;

            self.clipping=p.Results.clipping;
            self.OXmethod=p.Results.OXmethod;
</pre><pre class="codeoutput error">Error using chrislib.misprint (line 130)
Not enough input arguments.</pre><h2>start matlabpool if parallel computing tool box avaliable<a name="4"></a></h2><pre class="codeinput">            <span class="keyword">if</span> self.parallel
                <span class="keyword">if</span> license(<span class="string">'test'</span>, <span class="string">'distrib_computing_toolbox'</span>)
                    <span class="keyword">if</span> isempty(gcp(<span class="string">'nocreate'</span>))
                        parpool(<span class="string">'local'</span>)
                    <span class="keyword">end</span>
                <span class="keyword">else</span>
                    warning(<span class="string">'MISPRINT:init:useDistribComputingToolbox:notAvalaible'</span>,<span class="string">'The parallel computing toolbox is not avaliable, but has been requested.'</span>)
                <span class="keyword">end</span>
            <span class="keyword">end</span>
</pre><h2>root path<a name="5"></a></h2><pre class="codeinput">            self.rootDirectory=[pwd <span class="string">'/'</span>];
</pre><h2>main reduction target path construction<a name="6"></a></h2><pre class="codeinput">            self.targetBaseFilename=p.Results.targetBaseFilename;

            <span class="keyword">if</span> ~self.usecurrentfolderonly
                self.targetPath = [self.rootDirectory self.targetBaseFilename <span class="string">'/reduced/'</span> self.targetBaseFilename <span class="string">'-master.fit'</span>];
            <span class="keyword">else</span>
                self.targetPath = [self.rootDirectory self.targetBaseFilename <span class="string">'.fit'</span>];
            <span class="keyword">end</span>
            <span class="comment">% check the file is a valid fits.</span>
            self.checkForReducedFitsAt(self.targetPath);

            <span class="comment">% get fits header</span>
            self.targetHeader=fitsheader(self.targetPath);
</pre><h2>reference target path construction<a name="7"></a></h2><pre class="codeinput">            self.referenceBaseFilename=p.Results.reference;

            <span class="keyword">if</span> isempty(self.referenceBaseFilename)
                self.useReference     = false;
                self.spectraTracePath = [self.rootDirectory self.targetBaseFilename <span class="string">'-trace.mat'</span>];
            <span class="keyword">else</span>
                self.useReference     = true;
                self.spectraTracePath = [self.rootDirectory self.referenceBaseFilename <span class="string">'-trace.mat'</span>];
                <span class="keyword">if</span> ~self.usecurrentfolderonly
                    self.referencePath    = [self.rootDirectory self.referenceBaseFilename <span class="string">'/reduced/'</span> self.referenceBaseFilename <span class="string">'-master.fit'</span>];
                <span class="keyword">else</span>
                    self.referencePath    = [self.rootDirectory self.referenceBaseFilename <span class="string">'.fit'</span>];
                <span class="keyword">end</span>
                <span class="comment">% check the file is a valid fits.</span>
                self.checkForReducedFitsAt(self.targetPath);

                <span class="comment">% get fits header</span>
                self.referenceHeader  = fitsheader(self.referencePath);


                self.ReferenceSpectraFitsSaveFileName=[self.referenceBaseFilename <span class="string">'-1D-spectra.fits'</span>];
                self.referenceSpectraValues=fitsread(self.ReferenceSpectraFitsSaveFileName);

                self.FlatReferenceSpectraFitsSaveFileName=[self.referenceBaseFilename <span class="string">'-flattend-1D-spectra.fits'</span>];

                <span class="comment">%assertWarn(isfield(self.referenceHeader,'IMAGETYP') &amp;&amp; strcmp(self.referenceHeader.IMAGETYP,'Flat Frame'),...</span>
                <span class="comment">%    'MISPRINT:init:referenceNotAFlat',...</span>
                <span class="comment">%    'Reference Frame has not been tagged as a flat in fits header')</span>
            <span class="keyword">end</span>
</pre><h2>1D spectra filenames<a name="8"></a></h2><pre class="codeinput">            self.SpectraFitsSaveFileName=[self.targetBaseFilename <span class="string">'-1D-spectra.fits'</span>];
</pre><h2>check for required cards in fits header and read the values. add defaults where unavaliable.<a name="9"></a></h2><pre class="codeinput">            <span class="keyword">if</span> isfield(self.targetHeader,<span class="string">'READNOIS'</span>)
                self.readNoise=self.targetHeader.READNOIS;
            <span class="keyword">elseif</span> isfield(self.targetHeader,<span class="string">'RO_NOISE'</span>)
                self.readNoise=self.targetHeader.RO_NOISE;
            <span class="keyword">else</span>
                self.readNoise=11.3; <span class="comment">% atik default</span>
                <span class="comment">%                 if strcmp(self.targetHeader.INSTRUME,'ArtemisHSC')</span>
                <span class="comment">%                     fitsAddHeaderKeyword(self.targetPath,'READNOIS',self.readNoise,' ')</span>
                <span class="comment">%                 end</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> isfield(self.targetHeader,<span class="string">'GAIN'</span>)
                self.gain=self.targetHeader.GAIN;
            <span class="keyword">elseif</span> isfield(self.targetHeader,<span class="string">'RO_GAIN'</span>)
                self.gain=self.targetHeader.RO_GAIN;
            <span class="keyword">else</span>
                self.gain=0.43; <span class="comment">% fli default</span>
                <span class="comment">%                 if strcmp(self.targetHeader.INSTRUME,'ArtemisHSC')</span>
                <span class="comment">%                     fitsAddHeaderKeyword(self.targetPath,'GAIN',self.gain,' ')</span>
                <span class="comment">%                 end</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(self.dispAxis)
                <span class="keyword">if</span> isfield(self.targetHeader,<span class="string">'DISPAXIS'</span>)
                    self.dispAxis=self.targetHeader.DISPAXIS;
                <span class="keyword">else</span>
                    self.dispAxis=1; <span class="comment">% atik default</span>
                    <span class="comment">%if strcmp(self.targetHeader.INSTRUME,'ArtemisHSC')</span>
                    <span class="comment">%    fitsAddHeaderKeyword(self.targetPath,'DISPAXIS',self.dispAxis,' ');</span>
                    <span class="comment">%end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
</pre><h2>load misprint, and orientate so echelle dispersion is horizontal<a name="10"></a></h2><pre class="codeinput">            self.imdata=fitsread(self.targetPath);

            <span class="keyword">if</span> self.dispAxis==1
                self.imdata=fliplr(self.imdata'); <span class="comment">%</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> sum(self.clipping)
                <span class="comment">%[left top right bottom]</span>
                self.imdata=self.imdata(max([1 self.clipping(2)]):end-self.clipping(4),max([1 self.clipping(1)]):end-self.clipping(3));
                <span class="keyword">if</span> ~isempty(self.wavefit)
                    self.wavefit=self.wavefit(:,max([1 self.clipping(1)]):end-self.clipping(3),:);
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">%self.imdata=rot90(self.imdata,2);</span>
            self.imdim=size(self.imdata);
            self.imvariance=(self.readNoise/self.gain)^2 + abs(self.imdata) / self.gain; <span class="comment">%http://cxc.cfa.harvard.edu/mta/ASPECT/aca_read_noise/</span>
</pre><h2>trace col<a name="11"></a></h2><pre class="codeinput">            <span class="keyword">if</span> ~self.lastCol
                self.lastCol=self.imdim(2)-20;
            <span class="keyword">end</span>
            <span class="keyword">if</span> ~self.firstCol
                self.firstCol=20;
            <span class="keyword">end</span>
</pre><h2>load wavelength solution if supplied<a name="12"></a></h2><pre class="codeinput">            <span class="keyword">if</span> ~isempty(p.Results.wavesolution)
                self.wavematfile=p.Results.wavesolution;
                wavepayload=load(self.wavematfile,<span class="string">'p'</span>,<span class="string">'S'</span>,<span class="string">'mu'</span>);
                p=wavepayload.p;
                S=wavepayload.S;
                mu=wavepayload.mu;
                self.wavefit=zeros(self.numOfFibers,self.imdim(2),self.numOfOrders);
                <span class="keyword">for</span> o=1:self.numOfOrders;
                    <span class="keyword">for</span> f=1:self.numOfFibers;
                        self.wavefit(f,:,o)=polyval(p(f,:,o),1:self.imdim(2),S(f,:,o),mu(f,:,o));
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                self.diffractionOrder=round(2*1e-3/31.6*cosd(5)*sind(63.2)./(mean(squeeze(mean(self.wavefit,2)),1)*1e-9)');
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> runDefaultExtraction(self)
            <span class="comment">% run default set of extraction commands</span>

            self.getMaskForIncompleteOrders;
            self.traceSpectra;
            self.extractSpectra;
            self.getP2PVariationsAndBlaze
        <span class="keyword">end</span>

        <span class="keyword">function</span> traceSpectra(self,varargin)
</pre><pre class="codeinput">            <span class="comment">% trace spectra from flat.</span>
            <span class="comment">%</span>
            <span class="comment">% optional inputs misprint.traceSpectra(inputimage,numOfOrders,numOfFibers)</span>
            <span class="comment">% inputimage is same format as misprint.imdata</span>
</pre><h2>inital setup<a name="15"></a></h2><p>if preexisting trace exists it is loaded (unless forceTrace set)</p><pre class="codeinput">            <span class="keyword">if</span> nargin==1
                <span class="keyword">if</span> (~exist(self.spectraTracePath,<span class="string">'file'</span>) || self.forceTrace ) &amp;&amp; ~self.useReference

                    assertWarn(self.forceTrace &amp; exist(self.spectraTracePath,<span class="string">'file'</span>),<span class="keyword">...</span>
                        <span class="string">'MISPRINT:traceSpectra:TraceForced'</span>,<span class="keyword">...</span>
                        <span class="string">'Tracing was forced, this will overwrite previous trace.'</span>)

                    <span class="keyword">if</span> ~exist(self.spectraTracePath,<span class="string">'file'</span>); disp([<span class="string">'Tracefile: '</span> self.spectraTracePath <span class="string">' does not exist.'</span>]);<span class="keyword">end</span>
                <span class="keyword">else</span>
                    assert(~(self.forceTrace &amp; self.useReference),<span class="keyword">...</span>
                        <span class="string">'MISPRINT:traceSpectra:TraceForcedWithUseReferenceSet'</span>,<span class="keyword">...</span>
                        <span class="string">'Tracing can not be forced when useReference is set'</span>)

                    assert(~(self.useReference &amp; ~exist(self.spectraTracePath,<span class="string">'file'</span>)),<span class="keyword">...</span>
                        <span class="string">'MISPRINT:traceSpectra:ReferecnceTraceFileNotFound'</span>,<span class="keyword">...</span>
                        [self.spectraTracePath <span class="string">' was not found and is required as a reference. Aborting extraction.'</span>])

                    load(self.spectraTracePath,<span class="string">'specCenters'</span>,<span class="string">'specWidth'</span>,<span class="string">'orderWidth'</span>,<span class="string">'orderEdges'</span>,<span class="string">'means'</span>,<span class="string">'columns'</span>,<span class="string">'widths'</span>,<span class="string">'fitxs'</span>)

                    <span class="keyword">if</span> self.useReference
                        <span class="comment">%disp(['Using reference trace: ' self.spectraTracePath])</span>
                    <span class="keyword">else</span>
                        disp([<span class="string">'Using previous trace: '</span> self.spectraTracePath])
                    <span class="keyword">end</span>

                    self.meanSpecWidth=squeeze(mean(specWidth,2));
                    self.meanOrderWidth=squeeze(mean(orderWidth,2));
                    self.specCenters=specCenters;
                    self.specWidth=specWidth;
                    self.orderEdges=orderEdges;

                    self.fittedCenters=means;
                    self.fittedCol=columns;
                    self.fittedWidth=widths;
                    self.fittedParamters=fitxs;

                    <span class="keyword">return</span> <span class="comment">% end function call after loading data</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
</pre><h2>load data into local variables<a name="16"></a></h2><pre class="codeinput">            x=1:self.imdim(1);
            <span class="keyword">if</span> nargin==4
                inputimage = varargin{1};
                numOfOrders = varargin{2};
                numOfFibers = varargin{3};
            <span class="keyword">else</span>
                inputimage=self.imdata;
                numOfOrders = self.numOfOrders;
                numOfFibers = self.numOfFibers;
            <span class="keyword">end</span>

            imdata=inputimage.*self.mask;
</pre><h2>find orders<a name="17"></a></h2><pre class="codeinput">            <span class="keyword">if</span> (self.numTraceCol&gt;=self.imdim(2))
                columns=1:self.imdim(2);
                warning(<span class="string">'MISPRINT:fitAllOfTheThings'</span>,<span class="string">'You just asked for a fit to every column.'</span>)
                reply = input(<span class="string">'Are your sure?? Y/N [Y]: '</span>, <span class="string">'s'</span>);
                <span class="keyword">if</span> ~strcmpi(<span class="string">'Y'</span>,reply)
                    error(<span class="string">'MISPRINT:traceSpectra:userInterpupt'</span>,<span class="string">'MISPRINT termintated in traceSpectra.'</span>)
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                columns=round(linspace(self.firstCol, self.lastCol, self.numTraceCol));
            <span class="keyword">end</span>

            imcol=imdata(:,columns); <span class="comment">% sliced image</span>

            disp(<span class="string">'Running order tracer. This may take some time.'</span>)
            <span class="keyword">for</span> i=1:length(columns)
                [yp,index]=findpeaks(imcol(:,i),<span class="string">'NPEAKS'</span>,numOfOrders*numOfFibers,<span class="string">'MINPEAKHEIGHT'</span>,max(imcol(:,i))*self.peakcut,<span class="string">'MINPEAKDISTANCE'</span>,self.minPeakSeperation);
                <span class="keyword">if</span> self.plotAlot
                    figure(i);clf
                    plot(x,imcol(:,i),index,yp,<span class="string">'xr'</span>);
                    line([1 length(imcol(:,i))],[max(imcol(:,i)) max(imcol(:,i))]*self.peakcut)
                    title([num2str(columns(i))])
                <span class="keyword">end</span>
                <span class="keyword">if</span> numOfOrders==1
                    orderWidth=self.imdim(1);
                    orderCenter=round(self.imdim(1)/2);
                    orderEdges(:,i)=[1 self.imdim(1)];
                <span class="keyword">else</span>
                    orderWidth=diff(index(1:numOfFibers:end));
                    orderCenter=mean([index(numOfFibers:numOfFibers:end) index(1:numOfFibers:end)],2);
                    <span class="comment">%error(' ')</span>
                    orderEdges(:,i)=[orderCenter(1)-orderWidth(1)/2;<span class="keyword">...</span>
                        mean([index(numOfFibers:numOfFibers:end-numOfFibers)<span class="keyword">...</span>
                        index(numOfFibers+1:numOfFibers:end)],2); orderCenter(end)+orderWidth(end)/2];
                <span class="keyword">end</span>

                <span class="comment">%                 if self.plotAlot</span>
                <span class="comment">%                     plot(imcol(:,i))</span>
                <span class="comment">%                     hold on</span>
                <span class="comment">%                     %line(repmat(orderEdges(:,i)',[2,1]),[zeros(1,size(orderEdges(:,i),2)); ones(1,size(orderEdges(:,i),2))*max(imcol)])</span>
                <span class="comment">%                     hold off</span>
                <span class="comment">%                 end</span>
            <span class="keyword">end</span>
</pre><h2>trace orders<a name="18"></a></h2><p>fit gaussian to profile in columns for each order.</p><pre class="codeinput">            fitxs=zeros(numOfOrders,3*numOfFibers+1,length(columns));
            <span class="keyword">for</span> i=1:length(columns)
                <span class="keyword">for</span> order=1:numOfOrders
                    disp([<span class="string">'Column:'</span> num2str(columns(i)) <span class="string">' | Fitting Spectra in Order: '</span> num2str(order)])

                    orderProfileX=round(max(orderEdges(order,i),1):min(orderEdges(order+1,i),self.imdim(1)))';
                    orderProfile=imcol(orderProfileX,i);
                    orderProfile=orderProfile/max(orderProfile);


                    [~, means(order,:,i), widths(order,:,i), fitxs(order,:,i)] = <span class="keyword">...</span>
                        self.fitNGaussainsAlt(numOfFibers,orderProfileX, orderProfile,self.peakcut);

                    <span class="comment">%                    [~, means(order,:,i), widths(order,:,i), fitxs(order,:,i)] = ...</span>
                    <span class="comment">%                         fitNGaussains(numOfFibers,orderProfileX, orderProfile,self.peakcut,false);</span>

                    <span class="keyword">if</span> self.plotAlot
                        figure(i);clf;
                        <span class="comment">%subplot(5,4,columns)</span>
                        plot(orderProfileX,sum(self.nGausFunc(fitxs(order,:,i),orderProfileX,numOfFibers),2),<span class="string">'r-'</span>,<span class="keyword">...</span>
                            orderProfileX,orderProfile,<span class="string">'-'</span>)
                        title([<span class="string">'Order: '</span> num2str(order) <span class="string">' Column: '</span> num2str(columns(i))])
                        <span class="comment">%pause(0.1)</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            specCenters=self.polyfitwork(self.imdim,means,columns,3);
            specWidth=self.polyfitwork(self.imdim,widths,columns,3);
            meanSpecWidth=squeeze(mean(self.specWidth,3));

            self.fittedCenters=means;
            self.fittedCol=columns;
            self.fittedWidth=widths;

            self.meanSpecWidth=meanSpecWidth;
            self.specCenters=specCenters;
            self.specWidth=specWidth;
            self.orderEdges=orderEdges;
            self.fittedParamters=fitxs;
            self.meanOrderWidth=squeeze(mean(orderWidth,2));

            save(self.spectraTracePath,<span class="string">'specCenters'</span>,<span class="string">'specWidth'</span>,<span class="string">'orderWidth'</span>,<span class="string">'orderEdges'</span>,<span class="string">'means'</span>,<span class="string">'columns'</span>,<span class="string">'widths'</span>,<span class="string">'fitxs'</span>)
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> getMaskForIncompleteOrders(self)
            <span class="comment">%  get mask for incomplete orders</span>

            <span class="keyword">if</span> ~self.needsMask
                self.mask=ones(self.imdim);
                <span class="keyword">return</span> <span class="comment">% no clipe, so mask is ones.</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> isfield(self.targetHeader,<span class="string">'CLIPTL'</span>) &amp;&amp; isfield(self.targetHeader,<span class="string">'CLIPTR'</span>) &amp;&amp; isfield(self.targetHeader,<span class="string">'CLIPBL'</span>) &amp;&amp; isfield(self.targetHeader,<span class="string">'CLIPBR'</span>)
                topEdges=[self.targetHeader.CLIPTL self.targetHeader.CLIPTR];
                bottomEdges=[self.targetHeader.CLIPBL self.targetHeader.CLIPBR];
            <span class="keyword">else</span>
                self.forceDefineMaskEdge=true; <span class="comment">% overide default as clipping is needed, and data not defined</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> self.forceDefineMaskEdge
                echfig=figure(1);
                imagesc(self.imdata);
                axis([1 self.imdim(2) 1 self.imdim(1)*0.5]) <span class="comment">% show top half of image</span>
                [~,y]=getpts(echfig);
                topEdges=[y(1) y(2)];
                axis([1 self.imdim(2) self.imdim(1)-self.imdim(1)*0.3 self.imdim(1)]) <span class="comment">% show bottom third of image</span>
                [~,y]=getpts(echfig);
                bottomEdges=[y(1) y(2)];
            <span class="keyword">end</span>

            <span class="comment">% make mask of image to exclude incomplete orders</span>
            xi=[0; self.imdim(2);              self.imdim(2);                  0];
            yi=[0;        0;    topEdges(2); topEdges(1)];
            BW1 = roipoly(self.imdata,xi,yi);

            xi=[       0; self.imdim(2);           self.imdim(2);                  0];
            yi=[self.imdim(1); self.imdim(1);     bottomEdges(2);     bottomEdges(1)];

            BW2 = roipoly(self.imdata,xi,yi);
            self.mask=~BW1 &amp; ~BW2;

            <span class="keyword">if</span> self.forceDefineMaskEdge
                imagesc(self.imdata.*self.mask)
                reply = input(<span class="string">'Should I add to Fits Header Y/N [N]: '</span>, <span class="string">'s'</span>);
                <span class="keyword">if</span> isempty(reply)
                    reply = <span class="string">'N'</span>;
                <span class="keyword">end</span>
                <span class="keyword">if</span> strncmpi(reply,<span class="string">'Y'</span>,1)
                    disp(<span class="string">'saving clips to header'</span>)
                    fitsAddHeaderKeyword(self.targetPath,<span class="string">'CLIPTL'</span>,topEdges(1),<span class="string">' '</span>);
                    fitsAddHeaderKeyword(self.targetPath,<span class="string">'CLIPTR'</span>,topEdges(2),<span class="string">' '</span>);
                    fitsAddHeaderKeyword(self.targetPath,<span class="string">'CLIPBL'</span>,bottomEdges(1),<span class="string">' '</span>);
                    fitsAddHeaderKeyword(self.targetPath,<span class="string">'CLIPBR'</span>,bottomEdges(2),<span class="string">' '</span>);
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> self.plotAlot
                figure(1)
                imagesc(self.imdata.*self.mask)
            <span class="keyword">end</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span> getP2PVariationsAndBlaze(self,varargin)
            <span class="comment">% get smoothed version of flat spectrum (ie blaze) and pixel to</span>
            <span class="comment">% pixel variations (flatspectrum./smooth flat spectrum)</span>
            <span class="comment">%</span>
            <span class="comment">%  load reference</span>
            <span class="keyword">if</span> length(varargin)==2
                referenceFile=varargin{2};
            <span class="keyword">elseif</span> self.useReference
                referenceFile=self.ReferenceSpectraFitsSaveFileName;
            <span class="keyword">end</span>

            <span class="keyword">if</span> ~isempty(varargin)
                force=varargin{1};
            <span class="keyword">else</span>
                force=false;
            <span class="keyword">end</span>

            matpayload=load(self.spectraTracePath,<span class="string">'flatBlaze'</span>,<span class="string">'P2PVariationValues'</span>);
            <span class="keyword">if</span> ~force &amp;&amp; isfield(matpayload,<span class="string">'flatBlaze'</span>) &amp;&amp; isfield(matpayload,<span class="string">'P2PVariationValues'</span>)
                self.flatBlaze=matpayload.flatBlaze;
                self.P2PVariationValues=matpayload.P2PVariationValues;
            <span class="keyword">else</span>
                assertWarn(force,<span class="string">'MISPRINT:getP2PVariationsAndBlaze:forced'</span>,<span class="string">'P2P and blaze forced'</span>)
                mask=ones(self.numOfFibers,self.imdim(2));
                <span class="comment">%                 mask(end-50:end)=NaN;</span>
                <span class="comment">%                 mask(1:50)=NaN;</span>

                spectraValues=self.spectraValues;
                <span class="comment">%                 for or=1:self.numOfOrders</span>
                <span class="comment">%                     spectraValues(:,:,or)=bsxfun(@rdivide,spectraValues(:,:,or).*mask,max(spectraValues(:,:,or)')');</span>
                <span class="comment">%                 end</span>
                flatBlaze=zeros(size(self.spectraValues));
                P2PVariationValues=zeros(size(self.spectraValues));

                <span class="keyword">for</span> f=1:self.numOfFibers
                    <span class="keyword">for</span> or=1:self.numOfOrders
                        <span class="comment">%error('')</span>
                        flatBlaze(f,:,or)=csaps(1:self.imdim(2),spectraValues(f,:,or),1e-5,1:self.imdim(2));
                        <span class="comment">%flatBlaze(f,:,or)=smooth(spectraValues(f,:,or),100);</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                P2PVariationValues=spectraValues./flatBlaze;
                self.flatBlaze=flatBlaze;
                self.P2PVariationValues=P2PVariationValues;

                self.flatBlaze(isnan(self.flatBlaze))=1;
                self.P2PVariationValues(isnan(self.P2PVariationValues))=1;

                save(self.spectraTracePath,<span class="string">'flatBlaze'</span>,<span class="string">'P2PVariationValues'</span>,<span class="string">'-append'</span>)
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> getBlazeAlt(self,varargin)
            <span class="keyword">if</span> ~isempty(varargin)
                force=varargin{1};
            <span class="keyword">else</span>
                force=false;
            <span class="keyword">end</span>

            matpayload=load(self.spectraTracePath,<span class="string">'flatBlaze'</span>,<span class="string">'P2PVariationValues'</span>);
            <span class="keyword">if</span> ~force &amp;&amp; isfield(matpayload,<span class="string">'flatBlaze'</span>) &amp;&amp; isfield(matpayload,<span class="string">'P2PVariationValues'</span>)
                self.flatBlaze=matpayload.flatBlaze;
                self.P2PVariationValues=matpayload.P2PVariationValues;
            <span class="keyword">else</span>
</pre><pre class="codeinput">                assertWarn(force,<span class="string">'MISPRINT:getP2PVariationsAndBlaze:forced'</span>,<span class="string">'P2P and blaze forced'</span>)
</pre><pre class="codeinput">                x=[1:2498];

                opts1 = fitoptions( <span class="string">'Method'</span>, <span class="string">'LinearLeastSquares'</span> );
                opts1.Normalize = <span class="string">'on'</span>;
                ft1=fittype(<span class="string">'poly2'</span>);

                opts2 = fitoptions( <span class="string">'Method'</span>, <span class="string">'LinearLeastSquares'</span> );
                opts2.Normalize = <span class="string">'on'</span>;
                ft2=fittype(<span class="string">'poly3'</span>);
</pre><pre class="codeinput">                <span class="keyword">for</span> f=1:self.numOfFibers
                    <span class="keyword">for</span> o=1:self.numOfOrders
                        spec=self.spectraValues(f,:,o);

                        <span class="comment">% ft=fittype( 'smoothingspline' );</span>
                        <span class="comment">% opts = fitoptions( 'Method', 'SmoothingSpline' );</span>
                        <span class="comment">% opts.Normalize = 'on';</span>
                        <span class="comment">% opts.SmoothingParam = 1e-5;</span>

                        [fitresult, gof] = fit( x', spec', ft1, opts1);
                        <span class="comment">%plot(detrend(spec'./feval(fitresult,x))+1); grid on</span>

                        ignore=detrend(spec'./feval(fitresult,x))+1 &lt; 1;

                        [fitresult, gof] = fit( x(~ignore)', medfilt1(spec(~ignore),10)', ft2, opts2);

                        blaze=feval(fitresult,x);
                        flatBlaze(f,:,o)=blaze./max(blaze);
                        <span class="comment">%plot(x,squeeze(flatBlaze(f,:,o)),x,self.spectraValues(f,:,o)/max(self.spectraValues(f,:,o)))</span>
                        <span class="comment">%pause(0.2)</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>

                P2PVariationValues=ones(size(flatBlaze));
                self.flatBlaze=flatBlaze;
                self.P2PVariationValues=P2PVariationValues;

                <span class="comment">%save(self.spectraTracePath,'flatBlaze','P2PVariationValues','-append')</span>
</pre><pre class="codeinput">            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> plotSpectraValuesFor(self,orders,shouldFlat,shouldP2PV)
            <span class="comment">% plot spectra orders specifed. three arguments orders,shouldFlat,shouldP2PV</span>

            <span class="keyword">if</span> shouldFlat &amp;&amp; shouldP2PV
                FlattenedSpectra=self.spectraValues./self.flatBlaze./self.P2PVariationValues;
            <span class="keyword">elseif</span> shouldFlat &amp;&amp; ~shouldP2PV
                FlattenedSpectra=self.spectraValues./self.flatBlaze;
            <span class="keyword">elseif</span> ~shouldFlat &amp;&amp; shouldP2PV
                FlattenedSpectra=self.spectraValues./self.P2PVariationValues;
            <span class="keyword">else</span>
                FlattenedSpectra=self.spectraValues;
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(self.wavefit)
                <span class="keyword">for</span> order=orders
                    figure(order);clf;
                    subplot(1,2,1)
                    <span class="comment">%imagesc(log10(self.imdata-min2(self.imdata)+1))</span>
                    imagesc(self.imdata)
                    <span class="comment">%set(gca, 'CLim',[0 1000])</span>
                    ylim([min2(squeeze(self.specCenters(order,:,:)))-50 max2(squeeze(self.specCenters(order,:,:)))+50])
                    hold <span class="string">on</span>
                    plot(1:self.imdim(2),squeeze(self.specCenters(order,:,:)),<span class="string">'k'</span>,<span class="string">'LineWidth'</span>,1.5)
                    <span class="comment">%axis image</span>

                    subplot(1,2,2)
                    <span class="keyword">for</span> f=1:self.numOfFibers
                        FlattenedSpectraNorm(f,:,order)=FlattenedSpectra(f,:,order)/(max(FlattenedSpectra(f,:,order)));
                        plot(1:self.imdim(2),FlattenedSpectraNorm(f,:,order)+(self.numOfFibers-f)*0.2)
                        hold <span class="string">all</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                hold <span class="string">off</span>
                grid <span class="string">on</span>
            <span class="keyword">else</span>
                <span class="keyword">for</span> order=orders
                    figure(order);clf;

                    subplot(1,2,1)
                    imagesc(log10(self.imdata-min2(self.imdata)+1))
                    <span class="comment">%imagesc(self.imdata)</span>
                    <span class="comment">%set(gca, 'CLim',[0 1000])</span>
                    ylim([min2(squeeze(self.specCenters(order,:,:)))-50 max2(squeeze(self.specCenters(order,:,:)))+50])
                    hold <span class="string">on</span>
                    plot(1:self.imdim(2),squeeze(self.specCenters(order,:,:)),<span class="string">'k'</span>,<span class="string">'LineWidth'</span>,1.5)
                    title([<span class="string">'Order '</span> num2str(self.diffractionOrder(order))])
                    xlabel(<span class="string">'Primary-dispersion axis (pixels)'</span>)
                    ylabel(<span class="string">'Cross-dispersion axis (pixels)'</span>)

                    subplot(1,2,2)
                    <span class="keyword">for</span> f=1:self.numOfFibers
                        FlattenedSpectraNorm(f,:,order)=FlattenedSpectra(f,:,order)/max(FlattenedSpectra(f,:,order));
                        plot(self.wavefit(f,:,order),FlattenedSpectraNorm(f,:,order)+(self.numOfFibers-f)*0.2)
                        hold <span class="string">all</span>
                    <span class="keyword">end</span>

                    <span class="comment">%                     plot(self.wavefit(:,:,order)',FlattenedSpectra(:,:,order)')</span>
                    <span class="comment">%                     xlabel('Wavelength (nm)')</span>
                <span class="keyword">end</span>
                hold <span class="string">off</span>
                grid <span class="string">on</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> plotSingleFibre(self,f,shouldFlat,shouldP2PV)
            <span class="comment">% plot spectra for signle fibre across multiple orders, three arguments fibre,shouldFlat,shouldP2PV</span>
            <span class="keyword">if</span> shouldFlat &amp;&amp; shouldP2PV
                FlattenedSpectra=self.spectraValues./self.flatBlaze./self.P2PVariationValues;
            <span class="keyword">elseif</span> shouldFlat &amp;&amp; ~shouldP2PV
                FlattenedSpectra=self.spectraValues./self.flatBlaze;
            <span class="keyword">elseif</span> ~shouldFlat &amp;&amp; shouldP2PV
                FlattenedSpectra=self.spectraValues./self.P2PVariationValues;
            <span class="keyword">else</span>
                FlattenedSpectra=self.spectraValues;
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(self.wavefit)
                plot(bsxfun(@plus, repmat([1:self.imdim(2)],[self.numOfOrders 1])',[0:self.numOfOrders-1]*self.imdim(2)),squeeze(FlattenedSpectra(f,:,:)))
            <span class="keyword">else</span>
                plot(squeeze(self.wavefit(f,:,:)),squeeze(FlattenedSpectra(f,:,:)))
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> plotFinalSpectra(self)
            <span class="keyword">for</span> f=1:self.numOfFibers
                plot(self.finalWave,self.finalSpectra(f,:)+(self.numOfFibers-f)*2)
                hold <span class="string">all</span>
            <span class="keyword">end</span>
            hold <span class="string">off</span>
            xlabel(<span class="string">'Wavelength (nm)'</span>)
            hold <span class="string">on</span>
            orderwaveedges=squeeze(max(min(self.wavefit,[],2),[],1));
            line([orderwaveedges orderwaveedges], [0 40],<span class="string">'LineWidth'</span>,1,<span class="string">'Color'</span>,<span class="string">'k'</span>)

            hold <span class="string">off</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> plotFinalSpec(self)
            <span class="comment">%             [sunflux, sunwave] = getsunspec(min(self.finalWave), max(self.finalWave), 0.022);</span>
            <span class="comment">%             [telflux, telwave] = getTelluricSpec(min(self.finalWave), max(self.finalWave), 0.022);</span>
            <span class="comment">%</span>
            <span class="comment">%             plot(sunwave,sunflux,telwave,telflux)</span>
            <span class="comment">%            hold all</span>
            plot(self.finalWave,self.finalSpec/max(self.finalSpec))
            orderwaveedges=squeeze(max(min(self.wavefit,[],2),[],1));
            hold <span class="string">on</span>
            line([orderwaveedges orderwaveedges], [0 1],<span class="string">'LineWidth'</span>,2,<span class="string">'Color'</span>,<span class="string">'k'</span>)

            hold <span class="string">off</span>
            xlabel(<span class="string">'Wavelength (nm)'</span>)
        <span class="keyword">end</span>

        <span class="keyword">function</span> filterBadPixels(self,Nsigma,thresh,shouldPlot)
            <span class="comment">% filter bad pixels. three arguments Nsigma,thresh,shouldPlot</span>
            im=self.imdata;
            im(im&lt;=0)=1;

            imdiff=medfilt2(im,[2 2])./im; <span class="comment">% try and highlight odd pixels</span>

            imdiff=imdiff-mean2(imdiff); <span class="comment">% set mean to zero</span>

            bad1=imdiff&gt;thresh; <span class="comment">% very larger value can bias std, so clip them.</span>

            badpixel=(imdiff&gt;std2(imdiff(~bad1))*Nsigma | imdiff&lt;-std2(imdiff(~bad1))*Nsigma ) | bad1;

            self.imdata(badpixel)=NaN;

            self.imdata=inpaint_nans(self.imdata);

            <span class="keyword">if</span> shouldPlot
                figure(shouldPlot);clf
                [badx, bady]=find(badpixel);

                imagesc(self.imdata)
                hold <span class="string">on</span>
                shouldPlot(bady,badx,<span class="string">'wx'</span>)
                hold <span class="string">off</span>
            <span class="keyword">end</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span> blurred=removeIntensityGradientInImdata(self,avgWin)
            <span class="comment">% smooth whole image, then divided original by that. Usefull for to</span>
            <span class="comment">% improve flat tracing. one arguments avgWin (window for smoothing)</span>
            PSF = fspecial(<span class="string">'average'</span>, [1 1]*avgWin);

            blurred = imfilter(self.imdata, PSF, <span class="string">'conv'</span>, <span class="string">'symmetric'</span>);
            blurred=blurred/mean2(blurred);

            <span class="keyword">if</span> self.plotAlot
                subplot(1,3,1)
                imagesc(self.imdata)
                subplot(1,3,2)
                imagesc(blurred)
                subplot(1,3,3)
                imagesc(self.imdata./blurred)
            <span class="keyword">end</span>
            <span class="comment">%self.imdata=self.imdata./blurred;</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> getBackgroundBetweenOrders(self)
</pre><pre class="codeinput">            self.imdata(self.imdata&lt;0)=0;
            locs=self.orderEdges';
            locs(locs&gt;3362)=3362;

            imagesc(log10(self.imdata))
            hold <span class="string">on</span>;
            plot(self.fittedCol,locs',<span class="string">'bx'</span>)
            hold <span class="string">off</span>;
            pks=[];


            filtedimdata=medfilt2(self.imdata);

            <span class="comment">%locs(89,:)=(locs(88,:) + locs(90,:)) / 2;</span>

            <span class="keyword">for</span> i = 1:size(locs,2)
                <span class="comment">%    pks(i,:)=self.imdata(self.fittedCol,round(self.orderEdges(,:)));</span>
                p = impixel(filtedimdata,self.fittedCol,locs(:,i)');
                pks(:,i) = p(:,1);
            <span class="keyword">end</span>



            cols=self.fittedCol;
</pre><h2>scattered light estimate<a name="25"></a></h2><pre class="codeinput">            invertedimdata=(1./(self.imdata)).*self.mask;
            invertedimdata(isinf(invertedimdata))=0;
            figure(1)
            imagesc(log10(invertedimdata))
            x=1:self.imdim(1);


            inverpks=1./pks;
            cols2=repmat(cols,[size(locs,2),1])';
            figure(3);clf
            h(2)=surface(cols2,locs,pks,<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>);
            xlim([1 self.imdim(2)])
            ylim([1 self.imdim(1)])
            set(get(h(2),<span class="string">'Parent'</span>),<span class="string">'YDir'</span>,<span class="string">'reverse'</span>)


            figure(2);clf
            sfun=scateringTestFit(cols2, locs, inverpks);



            figure(4);clf
            [XI,YI]=meshgrid(1:self.imdim(2), 1:self.imdim(1));

            subplot(1,2,2)
            imagesc(1./feval(sfun,XI,YI).*self.mask)
            title(<span class="string">'Estimated Scattering (from Inter-Order Regions)'</span>)

            subplot(1,2,1)
            h(2)=surface(cols2,locs,1./pks,<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>);
            xlim([1 self.imdim(2)])
            ylim([1 self.imdim(1)])
            set(get(h(2),<span class="string">'Parent'</span>),<span class="string">'YDir'</span>,<span class="string">'reverse'</span>)


            <span class="comment">%self.imdata=self.imdata-feval(sfun,X,Y)</span>
            imagesc(self.imdata-1./feval(sfun,XI,YI))
            hold <span class="string">on</span>; plot(cols2,locs,<span class="string">'wx'</span>);hold <span class="string">off</span>
            title(<span class="string">'PIMMS Echelle Detector Image'</span>)

            <span class="comment">%self.imdata=self.imdata-1./feval(sfun,XI,YI)</span>
</pre><pre class="codeinput">            imagesc(log10(self.imdata))

            <span class="keyword">return</span>
            self.forceTrace=true;
            self.forceExtract=true;

            self.getMaskForIncompleteOrders;
            self.traceSpectra;
            <span class="comment">%self.specCenters=self.specCenters;</span>
            self.extractSpectra;
            self.getP2PVariationsAndBlaze
            set(0,<span class="string">'DefaultFigureWindowStyle'</span>,<span class="string">'docked'</span>)
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> spectraValues=extractSpectra(self)
            <span class="comment">% extract spectra using trace - each order done individually (faster).</span>

            <span class="keyword">if</span> ~exist(self.SpectraFitsSaveFileName,<span class="string">'file'</span>) || self.forceExtract
                spectraValues=zeros(self.numOfFibers,self.imdim(2),self.numOfOrders);
                spectraVar=zeros(self.numOfFibers,self.imdim(2),self.numOfOrders);
                backgroundValues=zeros(size(self.imdata));self.imdata;

                assertWarn(self.forceExtract,<span class="keyword">...</span>
                    <span class="string">'MISPRINT:extractSpectra:forceExtractFlagSet'</span>,<span class="keyword">...</span>
                    <span class="string">'Force extraction flag set, starting extraction. Data will be overwritten'</span>)
                RN=self.readNoise/self.gain;
                <span class="keyword">for</span> order=1:self.numOfOrders
                    spectra=zeros(self.numOfFibers,self.imdim(2));
                    specVar=zeros(self.numOfFibers,self.imdim(2));
                    <span class="comment">%background=zeros(size(self.imdata));</span>

                    <span class="comment">%disp(['Extracting Order: ' num2str(order)])</span>
                    orderSpecCenters=shiftdim(self.specCenters(order,:,:),1); <span class="comment">% clips order dim (1,f,col) &gt; (f,col)</span>

                    <span class="comment">% split into apetures</span>
                    <span class="keyword">for</span> col=1:self.imdim(2)

                        orderCenter=mean(orderSpecCenters(:,col));
                        profileApeture{col}=max(round(orderCenter-self.meanOrderWidth/2),1):<span class="keyword">...</span>
                            min(round(orderCenter+self.meanOrderWidth/2),self.imdim(1));

                        orderProfile{col}=self.imdata(profileApeture{col},col)';
                        varProfile{col}=self.imvariance(profileApeture{col},col)';

                    <span class="keyword">end</span>

                    <span class="comment">% do extraction</span>
                    <span class="comment">%                     for col=1:self.imdim(2)</span>
                    <span class="comment">%                         [spectra(:,col), specVar(:,col), background(col,:)]=self.(self.OXmethod)(...</span>
                    <span class="comment">%                             profileApeture(col,:),orderProfile(col,:),varProfile(col,:),...</span>
                    <span class="comment">%                             squeeze(self.specCenters(order,:,col))',...</span>
                    <span class="comment">%                             squeeze(2*log(2)*self.specWidth(order,:,col))',...</span>
                    <span class="comment">%                             self.readNoise/self.gain);</span>
                    <span class="comment">%                     end</span>

                    [spectra, specVar, background]=self.MPDoptimalExt(<span class="keyword">...</span>
                        profileApeture,orderProfile,varProfile,<span class="keyword">...</span>
                        (shiftdim(self.specCenters(order,:,:),1))',<span class="keyword">...</span>
                        2*log(2)*(shiftdim(self.specWidth(order,:,:),1))',<span class="keyword">...</span>
                        RN);



                    <span class="comment">% unfold into final variables</span>
                    <span class="keyword">for</span> col=1:self.imdim(2)
                        backgroundValues(profileApeture{col},col)=background{col};
                    <span class="keyword">end</span>
                    spectraValues(:,:,order)=spectra;
                    spectraVar(:,:,order)=specVar;
                <span class="keyword">end</span>

                spectra1DHDR=createcards(<span class="string">'NUMORDER'</span>,self.numOfOrders,<span class="string">'number of orders'</span>);
                spectra1DHDR.addcard(<span class="string">'NUMFIBER'</span>,self.numOfFibers,<span class="string">'number of fibers'</span>)
                spectra1DHDR.addcard(<span class="string">'TRACE'</span>,self.spectraTracePath,<span class="string">' '</span>)

                fitswrite(spectraValues,self.SpectraFitsSaveFileName,spectra1DHDR.cards)
                fitswrite(spectraVar,self.SpectraFitsSaveFileName,<span class="string">'writemode'</span>,<span class="string">'append'</span>)
                <span class="comment">%fitswrite(backgroundValues,self.SpectraFitsSaveFileName,'writemode','append')</span>
            <span class="keyword">else</span>
                disp([<span class="string">'Pre-existing extraction data found at: '</span> self.SpectraFitsSaveFileName])

                spectraValues=fitsread(self.SpectraFitsSaveFileName);
                spectraVar=fitsread(self.SpectraFitsSaveFileName,<span class="string">'image'</span>,1);
                <span class="comment">%backgroundValues=fitsread(self.SpectraFitsSaveFileName,'image',2);</span>
            <span class="keyword">end</span>
            self.spectraValues=spectraValues;
            self.spectraVar=spectraVar;
            <span class="comment">%self.backgroundValues=backgroundValues;</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> [spectraValues, spectraErrors, background, chi2]=MPDoptimalExtBack(self,dataRows,orderProfile,varProfile,specCenters,specWidth,RN)
            <span class="comment">% Multi-Profile Deconvolution Optimal Extraction as described by Sharp &amp; Birchall (2010)</span>
            <span class="comment">%</span>
            <span class="comment">% paper: Sharp R., Birchall M. N. (2010) Optimal Extraction of Fibre Optic Spectroscopy. PASA 27, pp. 91-103.</span>
            <span class="comment">%        http://dx.doi.org/10.1071/AS08001</span>


            <span class="keyword">if</span> iscolumn(orderProfile); orderProfile=orderProfile'; disp(1); <span class="keyword">end</span>
            <span class="keyword">if</span> iscolumn(varProfile); varProfile=varProfile'; disp(2); <span class="keyword">end</span>
            <span class="keyword">if</span> iscolumn(dataRows); dataRows=dataRows'; disp(3); <span class="keyword">end</span>
            <span class="keyword">if</span> isrow(specCenters);specCenters=specCenters'; disp(4); <span class="keyword">end</span>
            <span class="keyword">if</span> isrow(specWidth);specWidth=specWidth'; disp(5); <span class="keyword">end</span>
            <span class="comment">%            error(' ')</span>
            <span class="comment">%            save('testing.mat','self','dataRows','orderProfile','varProfile','specCenters','specWidth','RN')</span>

            phi=self.getPhi(dataRows,specCenters,2*log(2)*specWidth,[ones(length(specCenters),1)]);

            [xout,~,~,~] = fminsearch(@optimizeBackgroundFit, polyfit(dataRows,orderProfile/sum(orderProfile),1));

            [chi2, fittedValues, fittedErrors, M]=optimizeBackgroundFit(xout);

            spectraValues=fittedValues(1:end-1);
            spectraErrors=fittedErrors(1:end-1);
            background=fittedValues(end)*polyval(xout,dataRows)/sum(polyval(xout,dataRows));

            <span class="keyword">function</span> [chi2, fittedValues, fittedErrors, M]=optimizeBackgroundFit(x)
                <span class="comment">%setup</span>
                phifit=[phi; polyval(x,dataRows)/sum(polyval(x,dataRows))];<span class="comment">%ones(1,size(phi,2))/size(phi,2) %([1:size(phi,2)]*x(1)+x(2)) / sum([1:size(phi,2)]*x(1)+x(2))</span>
                sigmaweightedPhi=bsxfun(@rdivide,phifit,sqrt(varProfile))';
                c=phifit*sigmaweightedPhi;
                b=((orderProfile)*sigmaweightedPhi)';

                <span class="comment">%setup error</span>
                ce=phifit*phifit';
                be=((varProfile-RN^2)*phifit')';

                <span class="comment">%solve</span>
                fittedValues=c\b;
                fittedErrors=ce\be;

                <span class="comment">%Model</span>
                M=sum(bsxfun(@times,phifit,fittedValues),1);

                chi2=sum(((orderProfile-M)).^2./varProfile)/(size(M,2)-size(fittedValues,1)-length(x));
                <span class="comment">%                 if chi2&gt;1</span>
                <span class="comment">%                     plot(1:195,M,1:195,orderProfile)</span>
                <span class="comment">%                     drawnow;</span>
                <span class="comment">%                 end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> [spectraValues, spectraErrors, background]=MPDoptimalExt(self,dataRows,orderProfile,varProfile,specCenters,specWidth,RN)
            <span class="comment">% Multi-Profile Deconvolution Optimal Extraction as described by Sharp &amp; Birchall (2010)</span>
            <span class="comment">%</span>
            <span class="comment">% paper: Sharp R., Birchall M. N. (2010) Optimal Extraction of Fibre Optic Spectroscopy. PASA 27, pp. 91-103.</span>
            <span class="comment">%        http://dx.doi.org/10.1071/AS08001</span>

            <span class="comment">%setup</span>
            <span class="comment">%             if 0</span>
            <span class="comment">%                 phi=self.getPhi(dataRows,specCenters,specWidth,ones(length(specCenters),1));</span>
            <span class="comment">%             %%phi</span>
            <span class="comment">%             else</span>
            <span class="comment">%             phi1=;</span>
            <span class="comment">%             phi2=;</span>
            <span class="comment">%             phi3=</span>
            spectraValues=zeros(size(specCenters'));
            spectraErrors=spectraValues;
            <span class="keyword">for</span> col=1:size(specCenters,1)
                phi=bsxfun(@times, exp(-(bsxfun(@rdivide, bsxfun(@minus,repmat(dataRows{col},<span class="keyword">...</span>
                    [size(specCenters,2),1]),specCenters(col,:)'), specWidth(col,:)')).^2), 1./(specWidth(col,:)'*sqrt(pi)));
                <span class="comment">%phi=bsxfun(@times, phi4, specPeaks);</span>
                <span class="comment">%phi=sparse(phi);</span>
                phi(phi&lt;1e-6)=0;
                <span class="comment">%             end</span>

                <span class="comment">%            if 1</span>
                sigmaweightedPhi=bsxfun(@rdivide,phi,sqrt(varProfile{col}))';
                c=phi*sigmaweightedPhi;
                b=((orderProfile{col})*sigmaweightedPhi)';
                <span class="comment">%             else</span>
                <span class="comment">%                 sigmaweightedPhi=bsxfun(@rdivide,phi,sqrt(varProfile))';</span>
                <span class="comment">%                 c=mtimesx(phi,sigmaweightedPhi,'MATLAB');</span>
                <span class="comment">%                 b=mtimesx(orderProfile,sigmaweightedPhi,'MATLAB')';</span>
                <span class="comment">%             end</span>

                <span class="comment">%setup error</span>
                ce=phi*phi';
                be=((varProfile{col}-RN^2)*phi')';

                <span class="comment">%solve</span>
                spectraValues(:,col)=(c\b);
                <span class="comment">%spectraValues=linsolve(c,b);</span>
                spectraErrors(:,col)=(ce\be);
                <span class="comment">%spectraErrors=linsolve(ce,be);</span>

            <span class="keyword">end</span>
            background=cellfun(@(x) zeros(size(x)),orderProfile,<span class="string">'UniformOutput'</span>,false);

        <span class="keyword">end</span>

        <span class="keyword">function</span> [spectraValues, spectraErrors, background]=MPDoptimalExtOld(self,dataRows,orderProfile,varProfile,specCenters,specWidth,RN)
            <span class="comment">% Multi-Profile Deconvolution Optimal Extraction as described by Sharp &amp; Birchall (2010)</span>
            <span class="comment">%</span>
            <span class="comment">% paper: Sharp R., Birchall M. N. (2010) Optimal Extraction of Fibre Optic Spectroscopy. PASA 27, pp. 91-103.</span>
            <span class="comment">%        http://dx.doi.org/10.1071/AS08001</span>

            <span class="comment">%setup</span>
            <span class="comment">%             if 0</span>
            <span class="comment">%                 phi=self.getPhi(dataRows,specCenters,specWidth,ones(length(specCenters),1));</span>
            <span class="comment">%             %%phi</span>
            <span class="comment">%             else</span>
            phi1=bsxfun(@minus,repmat(dataRows,[length(specCenters),1]),specCenters);
            phi2=bsxfun(@rdivide, phi1, specWidth);
            phi3=exp(-(phi2).^2);
            phi=bsxfun(@times, phi3, 1./(specWidth*sqrt(pi)));
            <span class="comment">%phi=bsxfun(@times, phi4, specPeaks);</span>
            <span class="comment">%phi=sparse(phi);</span>
            phi(phi&lt;1e-8)=0;
            <span class="comment">%             end</span>

            <span class="comment">%            if 1</span>
            sigmaweightedPhi=bsxfun(@rdivide,phi,sqrt(varProfile))';
            c=phi*sigmaweightedPhi;
            b=((orderProfile)*sigmaweightedPhi)';
            <span class="comment">%             else</span>
            <span class="comment">%                 sigmaweightedPhi=bsxfun(@rdivide,phi,sqrt(varProfile))';</span>
            <span class="comment">%                 c=mtimesx(phi,sigmaweightedPhi,'MATLAB');</span>
            <span class="comment">%                 b=mtimesx(orderProfile,sigmaweightedPhi,'MATLAB')';</span>
            <span class="comment">%             end</span>

            <span class="comment">%setup error</span>
            ce=phi*phi';
            be=((varProfile-RN^2)*phi')';

            <span class="comment">%solve</span>
            spectraValues=(c\b);
            <span class="comment">%spectraValues=linsolve(c,b);</span>
            spectraErrors=(ce\be);
            <span class="comment">%spectraErrors=linsolve(ce,be);</span>
            background=zeros(size(orderProfile));

        <span class="keyword">end</span>

        <span class="keyword">function</span> phi=getPhi(~,dataRows,specCenters,specWidth,specPeaks)
            phi1=bsxfun(@minus,repmat(dataRows,[length(specCenters),1]),specCenters);
            phi2=bsxfun(@rdivide, phi1, specWidth);
            phi3=exp(-(phi2).^2);
            phi4=bsxfun(@times, phi3, 1./(specWidth*sqrt(pi)));
            phi=bsxfun(@times, phi4, specPeaks);
            <span class="comment">%phi=sparse(phi);</span>
            phi(phi&lt;1e-8)=0;
        <span class="keyword">end</span>

        <span class="keyword">function</span> lineariseAndCombineSpectrum(self,saveFiles)

            <span class="keyword">if</span> nargin==1
                saveFiles=false;
            <span class="keyword">end</span>

            spec=(self.spectraValues);<span class="comment">%./self.P2PVariationValues;%./self.flatBlaze;%</span>
            specVar=(self.spectraVar);<span class="comment">%./self.P2PVariationValues;%./self.flatBlaze;%</span>

            <span class="comment">%             for or=1:self.numOfOrders</span>
            <span class="comment">%                 specVar(:,:,or) = bsxfun(@rdivide,specVar(:,:,or),max(spec(:,:,or)')');</span>
            <span class="comment">%                 spec(:,:,or)    = bsxfun(@rdivide,spec(:,:,or),max(spec(:,:,or)')');</span>
            <span class="comment">%             end</span>

            longwavelinear=linspace(min(self.wavefit(:)),max(self.wavefit(:)),self.imdim(2)*self.numOfOrders);

            speclinearlong=zeros(self.numOfFibers,self.imdim(2)*self.numOfOrders,self.numOfOrders);
            spectraVarlinearlong=zeros(self.numOfFibers,self.imdim(2)*self.numOfOrders,self.numOfOrders);

            <span class="keyword">for</span> o=1:self.numOfOrders
                <span class="keyword">for</span> f=1:size(spec,1);
                    speclinearlong(f,:,o)=interp1(self.wavefit(f,:,o),spec(f,:,o),longwavelinear,<span class="string">'spline'</span>,0);
                    spectraVarlinearlong(f,:,o)=interp1(self.wavefit(f,:,o),specVar(f,:,o),longwavelinear,<span class="string">'spline'</span>,0);
                    specflatlong(f,:,o)=interp1(self.wavefit(f,:,o),self.flatBlaze(f,:,o),longwavelinear,<span class="string">'spline'</span>,0);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="comment">%specflatlong=ones(size(speclinearlong));</span>

            finalspeclong=nansum(speclinearlong,3)';<span class="comment">%./nansum(specflatlong,3)';</span>
            finalspecVarlong=nansum(spectraVarlinearlong,3)';<span class="comment">%./nansum(specflatlong,3)';</span>
            flatspeclong=nansum(specflatlong,3)';

            finalspeclong=finalspeclong./bsxfun(@rdivide,flatspeclong,mean(flatspeclong));
            finalspecVarlong=finalspecVarlong./bsxfun(@rdivide,flatspeclong,mean(flatspeclong));

            toclip=isnan(sum(finalspeclong,2));

            longwavelinear_clipped=longwavelinear(~toclip);
            finalspecVarlong_clipped=finalspecVarlong(~toclip,:);
            finalspeclong_clipped=finalspeclong(~toclip,:);

            self.finalSpectra=squeeze(finalspeclong_clipped');
            self.finalSpectraVar=squeeze(finalspecVarlong_clipped');
            self.finalWave=longwavelinear_clipped;

            self.finalSpec=squeeze(sum(finalspeclong_clipped,2)');
            self.finalSpecVar=squeeze(sum(finalspecVarlong_clipped,2)');

            <span class="keyword">if</span> 0
</pre><pre class="codeinput">                <span class="keyword">for</span> i=1:size(finalspecVarlong_clipped,2)
                    smoother(:,i)=csaps(self.finalWave,finalspecVarlong_clipped(:,i),0.0000001,self.finalWave);
                <span class="keyword">end</span>
</pre><pre class="codeinput">                smoother=mean(smoother,2)';
                <span class="comment">%[smoother] = blazeCorrection(self.finalSpec,self.finalWave,0.98)';</span>
</pre><pre class="codeinput">            <span class="keyword">else</span>
                smoother=1;
            <span class="keyword">end</span>
            <span class="comment">%            error(' ')</span>
            self.finalSpec=self.finalSpec./smoother;
            self.finalSpecVar=self.finalSpecVar./smoother;

            <span class="keyword">if</span> saveFiles
                header=self.targetHeader;
                header.IMAGETYP=<span class="string">'SPECTRUM'</span>;
                header.CRPIX1=round(length(self.finalWave)/2);
                header.CRVAL1=self.finalWave(header.CRPIX1);
                header.CTYPE1=<span class="string">'Wavelength'</span>;
                header.CUNIT1=<span class="string">'nm'</span>;
                header.CDELT1=mean(diff(self.finalWave));
                header.UTC=round((header.JD-floor(header.JD))*24*60*60);
                header.MJD=header.JD-2400000.5;
                header.DLAT=-33.873651000000000000;
                header.DLONG=151.206889600000070000;<span class="comment">%sydney</span>
                header.GEOELV=100;

                headercell1=fitstructure2cell(header);

                header2.EXTNAME=<span class="string">'FLUXERROR'</span>;
                headercell2=fitstructure2cell(header2);

                fitswrite(finalspeclong_clipped,[self.targetBaseFilename <span class="string">'-IndivCalSpec.fit'</span>],<span class="string">'keywords'</span>,headercell1(8:end,:))
                fitswrite(finalspecVarlong_clipped,[self.targetBaseFilename <span class="string">'-IndivCalSpec.fit'</span>],<span class="string">'writemode'</span>,<span class="string">'append'</span>,<span class="string">'keywords'</span>,headercell2)

                fitswrite(self.finalSpec,[self.targetBaseFilename <span class="string">'-CombCalSpec.fit'</span>],<span class="string">'keywords'</span>,headercell1(8:end,:))
                fitswrite(self.finalSpecVar,[self.targetBaseFilename <span class="string">'-CombCalSpec.fit'</span>],<span class="string">'writemode'</span>,<span class="string">'append'</span>,<span class="string">'keywords'</span>,headercell2)
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    methods (Static, Access = private)
        <span class="keyword">function</span> answer=checkForReducedFitsAt(path)
            <span class="comment">% check for a reduced target</span>
            <span class="keyword">try</span>
                import <span class="string">matlab.io.*</span>
                fptr = fits.openFile(path);
                fits.closeFile(fptr);
                answer=1;
            <span class="keyword">catch</span> err
                <span class="keyword">if</span> strcmp(err.identifier,<span class="string">'MATLAB:imagesci:fits:libraryError'</span>)
                    error(<span class="string">'MISPRINT:checkForReducedTarget:fitsOpenError'</span>,<span class="string">'Reduced fits file does not exist.'</span>)
                <span class="keyword">else</span>
                    rethrow(err)
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    methods (Static)
        [specCenters, p, mu]=polyfitwork(imdim,means,column,polyorder,offset,plotalot)
        prepareFrames
        [peaks,means,widths,xfitted] = fitNGaussainsAlt(N,x,y,peakcut,plotting)
        out=nGausFunc(x,xData,N)
        wavecalGUI
        autoimprovewavelength(varargin)
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
classdef misprint < handleAllHidden
    %MISPRINT MultIorder SPectroscopic ReductIoN Tool
    %
    % Properties are set using key value pairs.
    %
    % Sample Usage:
    %     s2r = misprint('sciencespectrum','reference','flatspectrum','plotAlot',true,...
    %         'usecurrentfolderonly',true,...
    %         'numOfOrders',14,'numOfFibers',29,...
    %         'forceTrace',false,'forceExtract',false,...
    %         'forceDefineMaskEdge',false,'needsMask',false,...
    %         'peakcut',0.07,'minPeakSeperation',3,...
    %         'numTraceCol',40,'firstCol',140,'lastCol',300,...
    %         'parallel',false);
    %
    %     self.getMaskForIncompleteOrders;
    %     self.traceSpectra;
    %     self.extractSpectra;
    %     self.getP2PVariationsAndBlaze(false);
    %
    %     self.plotSpectraFor(1:14,true,false)
    %
    % Copyright (C) Chris Betters 2012-2014
    
    properties
        targetBaseFilename, % base filename of target (file with spectra to be extracted) fits file.
        targetPath, % path to target fits file.
        rootDirectory, % path to current directory, should equal [pwd '/'].
        referenceBaseFilename, % base filename of reference fits file (i.e. a flat frame).
        referencePath, % path to reference fits file.
        
        targetHeader, % structure with target fits header.
        referenceHeader, % structure with reference fits header.
        
        SpectraFitsSaveFileName, % filename of fits file to save extracted spectra to.
        ReferenceSpectraFitsSaveFileName, % spectra previously extracted from the reference fits file.
        FlatReferenceSpectraFitsSaveFileName, % filename of fits file to for use as a flat reference, should be just pixel to pixel variations.
        
        spectraTracePath, % path to previously saved trace data for reference fits file.
        
        useReference, % flag to indicate if valid reference data has been set/ffound.
        plotAlot, % flag to show raw image and plots during tracing. It can plot alot.
        forceTrace, % flag to force a trace of spectra in the current image. Can not be set with a reference.
        forceExtract, % flag to force a new extraction of the current image. This will overwrite the default save file if it exists.
        forceDefineMaskEdge, % flag to force a new definition of the mask/clipping region.
        needsMask, % flag to indicate if image requires clipping.
        clipping, % vector of pixels from [left top right bottom] to clip.
        parallel, % flag tin indicate if parallel compuyting toolbox should/can be used.
        minPeakSeperation, % min peak seperation for tracing and peakfinder
        
        numOfOrders, % number of diffraction orders in image.
        numOfFibers, % number of spectra (fibres) in each order.
        
        gain, % gain (e-/adu) read from fits file
        readNoise, % read noise (rms e-) read from fits file
        dispAxis, % axis of primary dispersion read from fits file
        
        imdata, % target image data.
        imvariance, % estiamted variance for target image data.
        mask, % mask of clipped regions.
        imdim, % size of imdata (equals size(imdata))
        
        spectraValues, % extracted spectra values.
        spectraVar, % var for extracted spec values.
        backgroundValues, % background value from extraction
        
        finalSpectra, %  linearised version of complete spectrum for individual fibre (all orders)
        finalSpec, % linearised combined spectrum
        finalSpectraVar, % varience for finalSpectra
        finalSpecVar, % varience for finalSpec
        finalWave, % linearised wavelength scale for finalSpectra and finalSpec
        
        referenceSpectraValues, % extracted spectraValues of reference/flat
        P2PVariationValues, % pixel to pixel variation from reference.
        flatBlaze, % estimated blaze from reference.
        
        wavematfile, % mat file with wavelength fit paramaters
        wavefit,% wavelength soultion for each fibre
        diffractionOrder, % estimated diffraction order from wavefit
        
        numTraceCol, % number of columns to use when tracing.
        firstCol, % first column of trace
        lastCol, % last column of trace
        
        orderEdges,  % detected edges of the orders
        specCenters, % polynoimail interpolated fitted y axis centeres of the spectra from gaussain fit.
        specWidth,   % polynomial interpolated width of the spectra from gaussain fit.
        meanSpecWidth, % mean width of spceetra in each order.
        meanOrderWidth, % mean width of each order
        
        fittedCenters, % center of spectrum (vertical) from gaussian fit
        fittedCol, % column used to get progile for fit
        fittedWidth, % width of specturm (vertical) from gaussain fit
        fittedParamters, % all fit paramaters from trace
        
        usecurrentfolderonly, % flag to note use my maxiumDL/PIMMS echelle file structure.
        peakcut, % MINPEAKHEIGHT for spectra tracing detection. (fraction of mean of current profile).
        
        OXmethod, % name of method to use for optimal extraction.
    end
    
    methods
        function self=misprint(targetBaseFilename,varargin)
            % init the MISPRINT class. Pasre all inputs, load relevant files.
            
            %% parse inputs
            p = inputParser;
            
            p.addRequired('targetBaseFilename', @(x) ischar(x));
            p.addParamValue('reference','');
            p.addParamValue('forceTrace'            , false, @(x) islogical(x));
            p.addParamValue('forceExtract'          , false, @(x) islogical(x));
            p.addParamValue('plotAlot'      , false, @(x) islogical(x));
            p.addParamValue('forceDefineMaskEdge', false, @(x) islogical(x));
            p.addParamValue('needsMask', true, @(x) islogical(x));
            p.addParamValue('numOfOrders', 15, @(x) isnumeric(x));
            p.addParamValue('numOfFibers', 19, @(x) isnumeric(x));
            p.addParamValue('usecurrentfolderonly',false, @(x) islogical(x));
            p.addParamValue('peakcut', 0.8, @(x) isnumeric(x));
            p.addParamValue('parallel',true, @(x) islogical(x));
            p.addParamValue('numTraceCol', 10, @(x) isnumeric(x));
            p.addParamValue('dispAxis', [], @(x) isnumeric(x));
            p.addParamValue('wavesolution', '', @(x) ischar(x));
            p.addParamValue('minPeakSeperation', 3, @(x) isnumeric(x));
            p.addParamValue('firstCol', 0, @(x) isnumeric(x));
            p.addParamValue('lastCol', 0, @(x) isnumeric(x));
            p.addParamValue('clipping',[0 0 0 0], @(x) isnumeric(x) && length(x)==4)
            p.addParamValue('OXmethod','MPDoptimalExtBack', @(x) ismethod(self,x))
            
            p.parse(targetBaseFilename,varargin{:});
            
            self.numOfOrders=p.Results.numOfOrders;
            self.numOfFibers=p.Results.numOfFibers;
            self.forceExtract=p.Results.forceExtract;
            self.forceTrace=p.Results.forceTrace;
            self.plotAlot=p.Results.plotAlot;
            self.forceDefineMaskEdge=p.Results.forceDefineMaskEdge;
            self.needsMask=p.Results.needsMask;
            
            self.usecurrentfolderonly=p.Results.usecurrentfolderonly;
            self.peakcut=p.Results.peakcut;
            
            self.parallel=p.Results.parallel;
            self.numTraceCol=p.Results.numTraceCol;
            self.firstCol=p.Results.firstCol; %if zero set to 20 minus miage size (at end)
            self.lastCol=p.Results.lastCol; %if zero set to 20 minus miage size (at end of init)
            
            self.dispAxis=p.Results.dispAxis;
            
            self.minPeakSeperation=p.Results.minPeakSeperation;
            
            self.clipping=p.Results.clipping;
            self.OXmethod=p.Results.OXmethod;
            
            %% start matlabpool if parallel computing tool box avaliable
            if self.parallel
                if license('test', 'distrib_computing_toolbox')
                    if isempty(gcp('nocreate'))
                        parpool('local')
                    end
                else
                    warning('MISPRINT:init:useDistribComputingToolbox:notAvalaible','The parallel computing toolbox is not avaliable, but has been requested.')
                end
            end
            
            %% root path
            self.rootDirectory=[pwd '/'];
            
            %% main reduction target path construction
            self.targetBaseFilename=p.Results.targetBaseFilename;
            
            if ~self.usecurrentfolderonly
                self.targetPath = [self.rootDirectory self.targetBaseFilename '/reduced/' self.targetBaseFilename '-master.fit'];
            else
                self.targetPath = [self.rootDirectory self.targetBaseFilename '.fit'];
            end
            % check the file is a valid fits.
            self.checkForReducedFitsAt(self.targetPath);
            
            % get fits header
            self.targetHeader=fitsheader(self.targetPath);
            
            %% reference target path construction
            self.referenceBaseFilename=p.Results.reference;
            
            if isempty(self.referenceBaseFilename)
                self.useReference     = false;
                self.spectraTracePath = [self.rootDirectory self.targetBaseFilename '-trace.mat'];
            else
                self.useReference     = true;
                self.spectraTracePath = [self.rootDirectory self.referenceBaseFilename '-trace.mat'];
                if ~self.usecurrentfolderonly
                    self.referencePath    = [self.rootDirectory self.referenceBaseFilename '/reduced/' self.referenceBaseFilename '-master.fit'];
                else
                    self.referencePath    = [self.rootDirectory self.referenceBaseFilename '.fit'];
                end
                % check the file is a valid fits.
                self.checkForReducedFitsAt(self.targetPath);
                
                % get fits header
                self.referenceHeader  = fitsheader(self.referencePath);
                
                
                self.ReferenceSpectraFitsSaveFileName=[self.referenceBaseFilename '-1D-spectra.fits'];
                self.referenceSpectraValues=fitsread(self.ReferenceSpectraFitsSaveFileName);
                
                self.FlatReferenceSpectraFitsSaveFileName=[self.referenceBaseFilename '-flattend-1D-spectra.fits'];
                
                %assertWarn(isfield(self.referenceHeader,'IMAGETYP') && strcmp(self.referenceHeader.IMAGETYP,'Flat Frame'),...
                %    'MISPRINT:init:referenceNotAFlat',...
                %    'Reference Frame has not been tagged as a flat in fits header')
            end
            
            %% 1D spectra filenames
            self.SpectraFitsSaveFileName=[self.targetBaseFilename '-1D-spectra.fits'];
            
            %% check for required cards in fits header and read the values. add defaults where unavaliable.
            if isfield(self.targetHeader,'READNOIS')
                self.readNoise=self.targetHeader.READNOIS;
            elseif isfield(self.targetHeader,'RO_NOISE')
                self.readNoise=self.targetHeader.RO_NOISE;
            else
                self.readNoise=11.3; % atik default
                %                 if strcmp(self.targetHeader.INSTRUME,'ArtemisHSC')
                %                     fitsAddHeaderKeyword(self.targetPath,'READNOIS',self.readNoise,' ')
                %                 end
            end
            
            if isfield(self.targetHeader,'GAIN')
                self.gain=self.targetHeader.GAIN;
            elseif isfield(self.targetHeader,'RO_GAIN')
                self.gain=self.targetHeader.RO_GAIN;
            else
                self.gain=0.43; % fli default
                %                 if strcmp(self.targetHeader.INSTRUME,'ArtemisHSC')
                %                     fitsAddHeaderKeyword(self.targetPath,'GAIN',self.gain,' ')
                %                 end
            end
            
            if isempty(self.dispAxis)
                if isfield(self.targetHeader,'DISPAXIS')
                    self.dispAxis=self.targetHeader.DISPAXIS;
                else
                    self.dispAxis=1; % atik default
                    %if strcmp(self.targetHeader.INSTRUME,'ArtemisHSC')
                    %    fitsAddHeaderKeyword(self.targetPath,'DISPAXIS',self.dispAxis,' ');
                    %end
                end
            end
            %% load misprint, and orientate so echelle dispersion is horizontal
            self.imdata=fitsread(self.targetPath);
            
            if self.dispAxis==1
                self.imdata=fliplr(self.imdata'); %
            end
            
            if sum(self.clipping)
                %[left top right bottom]
                self.imdata=self.imdata(max([1 self.clipping(2)]):end-self.clipping(4),max([1 self.clipping(1)]):end-self.clipping(3));
                if ~isempty(self.wavefit)
                    self.wavefit=self.wavefit(:,max([1 self.clipping(1)]):end-self.clipping(3),:);
                end
            end
            
            %self.imdata=rot90(self.imdata,2);
            self.imdim=size(self.imdata);
            self.imvariance=(self.readNoise/self.gain)^2 + abs(self.imdata) / self.gain; %http://cxc.cfa.harvard.edu/mta/ASPECT/aca_read_noise/
            
            %% trace col
            if ~self.lastCol
                self.lastCol=self.imdim(2)-20;
            end
            if ~self.firstCol
                self.firstCol=20;
            end
            
            %% load wavelength solution if supplied
            if ~isempty(p.Results.wavesolution)
                self.wavematfile=p.Results.wavesolution;
                wavepayload=load(self.wavematfile,'p','S','mu');
                p=wavepayload.p;
                S=wavepayload.S;
                mu=wavepayload.mu;
                self.wavefit=zeros(self.numOfFibers,self.imdim(2),self.numOfOrders);
                for o=1:self.numOfOrders;
                    for f=1:self.numOfFibers;
                        self.wavefit(f,:,o)=polyval(p(f,:,o),1:self.imdim(2),S(f,:,o),mu(f,:,o));
                    end
                end
                self.diffractionOrder=round(2*1e-3/31.6*cosd(5)*sind(63.2)./(mean(squeeze(mean(self.wavefit,2)),1)*1e-9)');
            end
            
        end
        
        function runDefaultExtraction(self)
            % run default set of extraction commands
            
            self.getMaskForIncompleteOrders;
            self.traceSpectra;
            self.extractSpectra;
            self.getP2PVariationsAndBlaze
        end
        
        function traceSpectra(self,varargin)
            % trace spectra from flat.
            %
            % optional inputs misprint.traceSpectra(inputimage,numOfOrders,numOfFibers)
            % inputimage is same format as misprint.imdata
            
            %% inital setup
            % if preexisting trace exists it is loaded (unless forceTrace set)
            if nargin==1
                if (~exist(self.spectraTracePath,'file') || self.forceTrace ) && ~self.useReference
                    
                    assertWarn(self.forceTrace & exist(self.spectraTracePath,'file'),...
                        'MISPRINT:traceSpectra:TraceForced',...
                        'Tracing was forced, this will overwrite previous trace.')
                    
                    if ~exist(self.spectraTracePath,'file'); disp(['Tracefile: ' self.spectraTracePath ' does not exist.']);end
                else
                    assert(~(self.forceTrace & self.useReference),...
                        'MISPRINT:traceSpectra:TraceForcedWithUseReferenceSet',...
                        'Tracing can not be forced when useReference is set')
                    
                    assert(~(self.useReference & ~exist(self.spectraTracePath,'file')),...
                        'MISPRINT:traceSpectra:ReferecnceTraceFileNotFound',...
                        [self.spectraTracePath ' was not found and is required as a reference. Aborting extraction.'])
                    
                    load(self.spectraTracePath,'specCenters','specWidth','orderWidth','orderEdges','means','columns','widths','fitxs')
                    
                    if self.useReference
                        %disp(['Using reference trace: ' self.spectraTracePath])
                    else
                        disp(['Using previous trace: ' self.spectraTracePath])
                    end
                    
                    self.meanSpecWidth=squeeze(mean(specWidth,2));
                    self.meanOrderWidth=squeeze(mean(orderWidth,2));
                    self.specCenters=specCenters;
                    self.specWidth=specWidth;
                    self.orderEdges=orderEdges;
                    
                    self.fittedCenters=means;
                    self.fittedCol=columns;
                    self.fittedWidth=widths;
                    self.fittedParamters=fitxs;
                    
                    return % end function call after loading data
                end
            end
            
            %% load data into local variables
            x=1:self.imdim(1);
            if nargin==4
                inputimage = varargin{1};
                numOfOrders = varargin{2};
                numOfFibers = varargin{3};
            else
                inputimage=self.imdata;
                numOfOrders = self.numOfOrders;
                numOfFibers = self.numOfFibers;
            end
            
            imdata=inputimage.*self.mask;
            
            
            %% find orders
            if (self.numTraceCol>=self.imdim(2))
                columns=1:self.imdim(2);
                warning('MISPRINT:fitAllOfTheThings','You just asked for a fit to every column.')
                reply = input('Are your sure?? Y/N [Y]: ', 's');
                if ~strcmpi('Y',reply)
                    error('MISPRINT:traceSpectra:userInterpupt','MISPRINT termintated in traceSpectra.')
                end
            else
                columns=round(linspace(self.firstCol, self.lastCol, self.numTraceCol));
            end
            
            imcol=imdata(:,columns); % sliced image
            
            disp('Running order tracer. This may take some time.')
            for i=1:length(columns)
                [yp,index]=findpeaks(imcol(:,i),'NPEAKS',numOfOrders*numOfFibers,'MINPEAKHEIGHT',max(imcol(:,i))*self.peakcut,'MINPEAKDISTANCE',self.minPeakSeperation);
                if self.plotAlot
                    figure(i);clf
                    plot(x,imcol(:,i),index,yp,'xr');
                    line([1 length(imcol(:,i))],[max(imcol(:,i)) max(imcol(:,i))]*self.peakcut)
                    title([num2str(columns(i))])
                end
                if numOfOrders==1
                    orderWidth=self.imdim(1);
                    orderCenter=round(self.imdim(1)/2);
                    orderEdges(:,i)=[1 self.imdim(1)];
                else
                    orderWidth=diff(index(1:numOfFibers:end));
                    orderCenter=mean([index(numOfFibers:numOfFibers:end) index(1:numOfFibers:end)],2);
                    %error(' ')
                    orderEdges(:,i)=[orderCenter(1)-orderWidth(1)/2;...
                        mean([index(numOfFibers:numOfFibers:end-numOfFibers)...
                        index(numOfFibers+1:numOfFibers:end)],2); orderCenter(end)+orderWidth(end)/2];
                end
                
                %                 if self.plotAlot
                %                     plot(imcol(:,i))
                %                     hold on
                %                     %line(repmat(orderEdges(:,i)',[2,1]),[zeros(1,size(orderEdges(:,i),2)); ones(1,size(orderEdges(:,i),2))*max(imcol)])
                %                     hold off
                %                 end
            end
            
            %% trace orders
            % fit gaussian to profile in columns for each order.
            fitxs=zeros(numOfOrders,3*numOfFibers+1,length(columns));
            for i=1:length(columns)
                for order=1:numOfOrders
                    disp(['Column:' num2str(columns(i)) ' | Fitting Spectra in Order: ' num2str(order)])
                    
                    orderProfileX=round(max(orderEdges(order,i),1):min(orderEdges(order+1,i),self.imdim(1)))';
                    orderProfile=imcol(orderProfileX,i);
                    orderProfile=orderProfile/max(orderProfile);
                    
                    
                    [~, means(order,:,i), widths(order,:,i), fitxs(order,:,i)] = ...
                        self.fitNGaussainsAlt(numOfFibers,orderProfileX, orderProfile,self.peakcut);
                    
                    %                    [~, means(order,:,i), widths(order,:,i), fitxs(order,:,i)] = ...
                    %                         fitNGaussains(numOfFibers,orderProfileX, orderProfile,self.peakcut,false);
                    
                    if self.plotAlot
                        figure(i);clf;
                        %subplot(5,4,columns)
                        plot(orderProfileX,sum(self.nGausFunc(fitxs(order,:,i),orderProfileX,numOfFibers),2),'r-',...
                            orderProfileX,orderProfile,'-')
                        title(['Order: ' num2str(order) ' Column: ' num2str(columns(i))])
                        %pause(0.1)
                    end
                end
            end
            
            specCenters=self.polyfitwork(self.imdim,means,columns,3);
            specWidth=self.polyfitwork(self.imdim,widths,columns,3);
            meanSpecWidth=squeeze(mean(self.specWidth,3));
            
            self.fittedCenters=means;
            self.fittedCol=columns;
            self.fittedWidth=widths;
            
            self.meanSpecWidth=meanSpecWidth;
            self.specCenters=specCenters;
            self.specWidth=specWidth;
            self.orderEdges=orderEdges;
            self.fittedParamters=fitxs;
            self.meanOrderWidth=squeeze(mean(orderWidth,2));
            
            save(self.spectraTracePath,'specCenters','specWidth','orderWidth','orderEdges','means','columns','widths','fitxs')
        end
        
        function getMaskForIncompleteOrders(self)
            %  get mask for incomplete orders
            
            if ~self.needsMask
                self.mask=ones(self.imdim);
                return % no clipe, so mask is ones.
            end
            
            if isfield(self.targetHeader,'CLIPTL') && isfield(self.targetHeader,'CLIPTR') && isfield(self.targetHeader,'CLIPBL') && isfield(self.targetHeader,'CLIPBR')
                topEdges=[self.targetHeader.CLIPTL self.targetHeader.CLIPTR];
                bottomEdges=[self.targetHeader.CLIPBL self.targetHeader.CLIPBR];
            else
                self.forceDefineMaskEdge=true; % overide default as clipping is needed, and data not defined
            end
            
            if self.forceDefineMaskEdge
                echfig=figure(1);
                imagesc(self.imdata);
                axis([1 self.imdim(2) 1 self.imdim(1)*0.5]) % show top half of image
                [~,y]=getpts(echfig);
                topEdges=[y(1) y(2)];
                axis([1 self.imdim(2) self.imdim(1)-self.imdim(1)*0.3 self.imdim(1)]) % show bottom third of image
                [~,y]=getpts(echfig);
                bottomEdges=[y(1) y(2)];
            end
            
            % make mask of image to exclude incomplete orders
            xi=[0; self.imdim(2);              self.imdim(2);                  0];
            yi=[0;        0;    topEdges(2); topEdges(1)];
            BW1 = roipoly(self.imdata,xi,yi);
            
            xi=[       0; self.imdim(2);           self.imdim(2);                  0];
            yi=[self.imdim(1); self.imdim(1);     bottomEdges(2);     bottomEdges(1)];
            
            BW2 = roipoly(self.imdata,xi,yi);
            self.mask=~BW1 & ~BW2;
            
            if self.forceDefineMaskEdge
                imagesc(self.imdata.*self.mask)
                reply = input('Should I add to Fits Header Y/N [N]: ', 's');
                if isempty(reply)
                    reply = 'N';
                end
                if strncmpi(reply,'Y',1)
                    disp('saving clips to header')
                    fitsAddHeaderKeyword(self.targetPath,'CLIPTL',topEdges(1),' ');
                    fitsAddHeaderKeyword(self.targetPath,'CLIPTR',topEdges(2),' ');
                    fitsAddHeaderKeyword(self.targetPath,'CLIPBL',bottomEdges(1),' ');
                    fitsAddHeaderKeyword(self.targetPath,'CLIPBR',bottomEdges(2),' ');
                end
            end
            
            if self.plotAlot
                figure(1)
                imagesc(self.imdata.*self.mask)
            end
            
        end
        
        function getP2PVariationsAndBlaze(self,varargin)
            % get smoothed version of flat spectrum (ie blaze) and pixel to
            % pixel variations (flatspectrum./smooth flat spectrum)
            %
            %  load reference
            if length(varargin)==2
                referenceFile=varargin{2};
            elseif self.useReference
                referenceFile=self.ReferenceSpectraFitsSaveFileName;
            end
            
            if ~isempty(varargin)
                force=varargin{1};
            else
                force=false;
            end
            
            matpayload=load(self.spectraTracePath,'flatBlaze','P2PVariationValues');
            if ~force && isfield(matpayload,'flatBlaze') && isfield(matpayload,'P2PVariationValues')
                self.flatBlaze=matpayload.flatBlaze;
                self.P2PVariationValues=matpayload.P2PVariationValues;
            else
                assertWarn(force,'MISPRINT:getP2PVariationsAndBlaze:forced','P2P and blaze forced')
                mask=ones(self.numOfFibers,self.imdim(2));
                %                 mask(end-50:end)=NaN;
                %                 mask(1:50)=NaN;
                
                spectraValues=self.spectraValues;
                %                 for or=1:self.numOfOrders
                %                     spectraValues(:,:,or)=bsxfun(@rdivide,spectraValues(:,:,or).*mask,max(spectraValues(:,:,or)')');
                %                 end
                flatBlaze=zeros(size(self.spectraValues));
                P2PVariationValues=zeros(size(self.spectraValues));
                
                for f=1:self.numOfFibers
                    for or=1:self.numOfOrders
                        %error('')
                        flatBlaze(f,:,or)=csaps(1:self.imdim(2),spectraValues(f,:,or),1e-5,1:self.imdim(2));
                        %flatBlaze(f,:,or)=smooth(spectraValues(f,:,or),100);
                    end
                end
                P2PVariationValues=spectraValues./flatBlaze;
                self.flatBlaze=flatBlaze;
                self.P2PVariationValues=P2PVariationValues;
                
                self.flatBlaze(isnan(self.flatBlaze))=1;
                self.P2PVariationValues(isnan(self.P2PVariationValues))=1;
                
                save(self.spectraTracePath,'flatBlaze','P2PVariationValues','-append')
            end
        end
        
        function getBlazeAlt(self,varargin)
            if ~isempty(varargin)
                force=varargin{1};
            else
                force=false;
            end
            
            matpayload=load(self.spectraTracePath,'flatBlaze','P2PVariationValues');
            if ~force && isfield(matpayload,'flatBlaze') && isfield(matpayload,'P2PVariationValues')
                self.flatBlaze=matpayload.flatBlaze;
                self.P2PVariationValues=matpayload.P2PVariationValues;
            else
                assertWarn(force,'MISPRINT:getP2PVariationsAndBlaze:forced','P2P and blaze forced')
                
                %%
                x=[1:2498];
                
                opts1 = fitoptions( 'Method', 'LinearLeastSquares' );
                opts1.Normalize = 'on';
                ft1=fittype('poly2');
                
                opts2 = fitoptions( 'Method', 'LinearLeastSquares' );
                opts2.Normalize = 'on';
                ft2=fittype('poly3');
                %%
                for f=1:self.numOfFibers
                    for o=1:self.numOfOrders
                        spec=self.spectraValues(f,:,o);
                        
                        % ft=fittype( 'smoothingspline' );
                        % opts = fitoptions( 'Method', 'SmoothingSpline' );
                        % opts.Normalize = 'on';
                        % opts.SmoothingParam = 1e-5;
                        
                        [fitresult, gof] = fit( x', spec', ft1, opts1);
                        %plot(detrend(spec'./feval(fitresult,x))+1); grid on
                        
                        ignore=detrend(spec'./feval(fitresult,x))+1 < 1;
                        
                        [fitresult, gof] = fit( x(~ignore)', medfilt1(spec(~ignore),10)', ft2, opts2);
                        
                        blaze=feval(fitresult,x);
                        flatBlaze(f,:,o)=blaze./max(blaze);
                        %plot(x,squeeze(flatBlaze(f,:,o)),x,self.spectraValues(f,:,o)/max(self.spectraValues(f,:,o)))
                        %pause(0.2)
                    end
                end
                
                P2PVariationValues=ones(size(flatBlaze));
                self.flatBlaze=flatBlaze;
                self.P2PVariationValues=P2PVariationValues;
                
                %save(self.spectraTracePath,'flatBlaze','P2PVariationValues','-append')
            end
        end
        
        function plotSpectraValuesFor(self,orders,shouldFlat,shouldP2PV)
            % plot spectra orders specifed. three arguments orders,shouldFlat,shouldP2PV
            
            if shouldFlat && shouldP2PV
                FlattenedSpectra=self.spectraValues./self.flatBlaze./self.P2PVariationValues;
            elseif shouldFlat && ~shouldP2PV
                FlattenedSpectra=self.spectraValues./self.flatBlaze;
            elseif ~shouldFlat && shouldP2PV
                FlattenedSpectra=self.spectraValues./self.P2PVariationValues;
            else
                FlattenedSpectra=self.spectraValues;
            end
            
            if isempty(self.wavefit)
                for order=orders
                    figure(order);clf;
                    subplot(1,2,1)
                    %imagesc(log10(self.imdata-min2(self.imdata)+1))
                    imagesc(self.imdata)
                    %set(gca, 'CLim',[0 1000])
                    ylim([min2(squeeze(self.specCenters(order,:,:)))-50 max2(squeeze(self.specCenters(order,:,:)))+50])
                    hold on
                    plot(1:self.imdim(2),squeeze(self.specCenters(order,:,:)),'k','LineWidth',1.5)
                    %axis image
                    
                    subplot(1,2,2)
                    for f=1:self.numOfFibers
                        FlattenedSpectraNorm(f,:,order)=FlattenedSpectra(f,:,order)/(max(FlattenedSpectra(f,:,order)));
                        plot(1:self.imdim(2),FlattenedSpectraNorm(f,:,order)+(self.numOfFibers-f)*0.2)
                        hold all
                    end
                end
                hold off
                grid on
            else
                for order=orders
                    figure(order);clf;
                    
                    subplot(1,2,1)
                    imagesc(log10(self.imdata-min2(self.imdata)+1))
                    %imagesc(self.imdata)
                    %set(gca, 'CLim',[0 1000])
                    ylim([min2(squeeze(self.specCenters(order,:,:)))-50 max2(squeeze(self.specCenters(order,:,:)))+50])
                    hold on
                    plot(1:self.imdim(2),squeeze(self.specCenters(order,:,:)),'k','LineWidth',1.5)
                    title(['Order ' num2str(self.diffractionOrder(order))])
                    xlabel('Primary-dispersion axis (pixels)')
                    ylabel('Cross-dispersion axis (pixels)')
                    
                    subplot(1,2,2)
                    for f=1:self.numOfFibers
                        FlattenedSpectraNorm(f,:,order)=FlattenedSpectra(f,:,order)/max(FlattenedSpectra(f,:,order));
                        plot(self.wavefit(f,:,order),FlattenedSpectraNorm(f,:,order)+(self.numOfFibers-f)*0.2)
                        hold all
                    end
                    
                    %                     plot(self.wavefit(:,:,order)',FlattenedSpectra(:,:,order)')
                    %                     xlabel('Wavelength (nm)')
                end
                hold off
                grid on
            end
        end
        
        function plotSingleFibre(self,f,shouldFlat,shouldP2PV)
            % plot spectra for signle fibre across multiple orders, three arguments fibre,shouldFlat,shouldP2PV
            if shouldFlat && shouldP2PV
                FlattenedSpectra=self.spectraValues./self.flatBlaze./self.P2PVariationValues;
            elseif shouldFlat && ~shouldP2PV
                FlattenedSpectra=self.spectraValues./self.flatBlaze;
            elseif ~shouldFlat && shouldP2PV
                FlattenedSpectra=self.spectraValues./self.P2PVariationValues;
            else
                FlattenedSpectra=self.spectraValues;
            end
            
            if isempty(self.wavefit)
                plot(bsxfun(@plus, repmat([1:self.imdim(2)],[self.numOfOrders 1])',[0:self.numOfOrders-1]*self.imdim(2)),squeeze(FlattenedSpectra(f,:,:)))
            else
                plot(squeeze(self.wavefit(f,:,:)),squeeze(FlattenedSpectra(f,:,:)))
            end
        end
        
        function plotFinalSpectra(self)
            for f=1:self.numOfFibers
                plot(self.finalWave,self.finalSpectra(f,:)+(self.numOfFibers-f)*2)
                hold all
            end
            hold off
            xlabel('Wavelength (nm)')
            hold on
            orderwaveedges=squeeze(max(min(self.wavefit,[],2),[],1));
            line([orderwaveedges orderwaveedges], [0 40],'LineWidth',1,'Color','k')
            
            hold off
        end
        
        function plotFinalSpec(self)
            %             [sunflux, sunwave] = getsunspec(min(self.finalWave), max(self.finalWave), 0.022);
            %             [telflux, telwave] = getTelluricSpec(min(self.finalWave), max(self.finalWave), 0.022);
            %
            %             plot(sunwave,sunflux,telwave,telflux)
            %            hold all
            plot(self.finalWave,self.finalSpec/max(self.finalSpec))
            orderwaveedges=squeeze(max(min(self.wavefit,[],2),[],1));
            hold on
            line([orderwaveedges orderwaveedges], [0 1],'LineWidth',2,'Color','k')
            
            hold off
            xlabel('Wavelength (nm)')
        end
        
        function filterBadPixels(self,Nsigma,thresh,shouldPlot)
            % filter bad pixels. three arguments Nsigma,thresh,shouldPlot
            im=self.imdata;
            im(im<=0)=1;
            
            imdiff=medfilt2(im,[2 2])./im; % try and highlight odd pixels
            
            imdiff=imdiff-mean2(imdiff); % set mean to zero
            
            bad1=imdiff>thresh; % very larger value can bias std, so clip them.
            
            badpixel=(imdiff>std2(imdiff(~bad1))*Nsigma | imdiff<-std2(imdiff(~bad1))*Nsigma ) | bad1;
            
            self.imdata(badpixel)=NaN;
            
            self.imdata=inpaint_nans(self.imdata);
            
            if shouldPlot
                figure(shouldPlot);clf
                [badx, bady]=find(badpixel);
                
                imagesc(self.imdata)
                hold on
                shouldPlot(bady,badx,'wx')
                hold off
            end
            
        end
        
        function blurred=removeIntensityGradientInImdata(self,avgWin)
            % smooth whole image, then divided original by that. Usefull for to
            % improve flat tracing. one arguments avgWin (window for smoothing)
            PSF = fspecial('average', [1 1]*avgWin);
            
            blurred = imfilter(self.imdata, PSF, 'conv', 'symmetric');
            blurred=blurred/mean2(blurred);
            
            if self.plotAlot
                subplot(1,3,1)
                imagesc(self.imdata)
                subplot(1,3,2)
                imagesc(blurred)
                subplot(1,3,3)
                imagesc(self.imdata./blurred)
            end
            %self.imdata=self.imdata./blurred;
        end
        
        function getBackgroundBetweenOrders(self)
            self.imdata(self.imdata<0)=0;
            locs=self.orderEdges';
            locs(locs>3362)=3362;
            
            imagesc(log10(self.imdata))
            hold on;
            plot(self.fittedCol,locs','bx')
            hold off;
            pks=[];
            
            
            filtedimdata=medfilt2(self.imdata);
            
            %locs(89,:)=(locs(88,:) + locs(90,:)) / 2;
            
            for i = 1:size(locs,2)
                %    pks(i,:)=self.imdata(self.fittedCol,round(self.orderEdges(,:)));
                p = impixel(filtedimdata,self.fittedCol,locs(:,i)');
                pks(:,i) = p(:,1);
            end
            
            
            
            cols=self.fittedCol;
            
            
            
            %% scattered light estimate
            
            invertedimdata=(1./(self.imdata)).*self.mask;
            invertedimdata(isinf(invertedimdata))=0;
            figure(1)
            imagesc(log10(invertedimdata))
            x=1:self.imdim(1);
            
            
            inverpks=1./pks;
            cols2=repmat(cols,[size(locs,2),1])';
            figure(3);clf
            h(2)=surface(cols2,locs,pks,'EdgeColor','none');
            xlim([1 self.imdim(2)])
            ylim([1 self.imdim(1)])
            set(get(h(2),'Parent'),'YDir','reverse')
            
            
            figure(2);clf
            sfun=scateringTestFit(cols2, locs, inverpks);
            
            
            
            figure(4);clf
            [XI,YI]=meshgrid(1:self.imdim(2), 1:self.imdim(1));
            
            subplot(1,2,2)
            imagesc(1./feval(sfun,XI,YI).*self.mask)
            title('Estimated Scattering (from Inter-Order Regions)')
            
            subplot(1,2,1)
            h(2)=surface(cols2,locs,1./pks,'EdgeColor','none');
            xlim([1 self.imdim(2)])
            ylim([1 self.imdim(1)])
            set(get(h(2),'Parent'),'YDir','reverse')
            
            
            %self.imdata=self.imdata-feval(sfun,X,Y)
            imagesc(self.imdata-1./feval(sfun,XI,YI))
            hold on; plot(cols2,locs,'wx');hold off
            title('PIMMS Echelle Detector Image')
            
            %self.imdata=self.imdata-1./feval(sfun,XI,YI)
            
            
            %%
            
            imagesc(log10(self.imdata))
            
            return
            self.forceTrace=true;
            self.forceExtract=true;
            
            self.getMaskForIncompleteOrders;
            self.traceSpectra;
            %self.specCenters=self.specCenters;
            self.extractSpectra;
            self.getP2PVariationsAndBlaze
            set(0,'DefaultFigureWindowStyle','docked')
            
        end
        
        function spectraValues=extractSpectra(self)
            % extract spectra using trace - each order done individually (faster).
            
            if ~exist(self.SpectraFitsSaveFileName,'file') || self.forceExtract
                spectraValues=zeros(self.numOfFibers,self.imdim(2),self.numOfOrders);
                spectraVar=zeros(self.numOfFibers,self.imdim(2),self.numOfOrders);
                backgroundValues=zeros(size(self.imdata));self.imdata;
                
                assertWarn(self.forceExtract,...
                    'MISPRINT:extractSpectra:forceExtractFlagSet',...
                    'Force extraction flag set, starting extraction. Data will be overwritten')
                RN=self.readNoise/self.gain;
                for order=1:self.numOfOrders
                    spectra=zeros(self.numOfFibers,self.imdim(2));
                    specVar=zeros(self.numOfFibers,self.imdim(2));
                    %background=zeros(size(self.imdata));
                    
                    %disp(['Extracting Order: ' num2str(order)])
                    orderSpecCenters=shiftdim(self.specCenters(order,:,:),1); % clips order dim (1,f,col) > (f,col)
                    
                    % split into apetures
                    for col=1:self.imdim(2)
                        
                        orderCenter=mean(orderSpecCenters(:,col));
                        profileApeture{col}=max(round(orderCenter-self.meanOrderWidth/2),1):...
                            min(round(orderCenter+self.meanOrderWidth/2),self.imdim(1));
                        
                        orderProfile{col}=self.imdata(profileApeture{col},col)';
                        varProfile{col}=self.imvariance(profileApeture{col},col)';
                        
                    end
                    
                    % do extraction
                    %                     for col=1:self.imdim(2)
                    %                         [spectra(:,col), specVar(:,col), background(col,:)]=self.(self.OXmethod)(...
                    %                             profileApeture(col,:),orderProfile(col,:),varProfile(col,:),...
                    %                             squeeze(self.specCenters(order,:,col))',...
                    %                             squeeze(2*log(2)*self.specWidth(order,:,col))',...
                    %                             self.readNoise/self.gain);
                    %                     end
                    
                    [spectra, specVar, background]=self.MPDoptimalExt(...
                        profileApeture,orderProfile,varProfile,...
                        (shiftdim(self.specCenters(order,:,:),1))',...
                        2*log(2)*(shiftdim(self.specWidth(order,:,:),1))',...
                        RN);
                    
                    
                   
                    % unfold into final variables
                    for col=1:self.imdim(2)
                        backgroundValues(profileApeture{col},col)=background{col};
                    end
                    spectraValues(:,:,order)=spectra;
                    spectraVar(:,:,order)=specVar;
                end
                
                spectra1DHDR=createcards('NUMORDER',self.numOfOrders,'number of orders');
                spectra1DHDR.addcard('NUMFIBER',self.numOfFibers,'number of fibers')
                spectra1DHDR.addcard('TRACE',self.spectraTracePath,' ')
                
                fitswrite(spectraValues,self.SpectraFitsSaveFileName,spectra1DHDR.cards)
                fitswrite(spectraVar,self.SpectraFitsSaveFileName,'writemode','append')
                %fitswrite(backgroundValues,self.SpectraFitsSaveFileName,'writemode','append')
            else
                disp(['Pre-existing extraction data found at: ' self.SpectraFitsSaveFileName])
                
                spectraValues=fitsread(self.SpectraFitsSaveFileName);
                spectraVar=fitsread(self.SpectraFitsSaveFileName,'image',1);
                %backgroundValues=fitsread(self.SpectraFitsSaveFileName,'image',2);
            end
            self.spectraValues=spectraValues;
            self.spectraVar=spectraVar;
            %self.backgroundValues=backgroundValues;
        end
        
        function [spectraValues, spectraErrors, background, chi2]=MPDoptimalExtBack(self,dataRows,orderProfile,varProfile,specCenters,specWidth,RN)
            % Multi-Profile Deconvolution Optimal Extraction as described by Sharp & Birchall (2010)
            %
            % paper: Sharp R., Birchall M. N. (2010) Optimal Extraction of Fibre Optic Spectroscopy. PASA 27, pp. 91-103.
            %        http://dx.doi.org/10.1071/AS08001
            
            
            if iscolumn(orderProfile); orderProfile=orderProfile'; disp(1); end
            if iscolumn(varProfile); varProfile=varProfile'; disp(2); end
            if iscolumn(dataRows); dataRows=dataRows'; disp(3); end
            if isrow(specCenters);specCenters=specCenters'; disp(4); end
            if isrow(specWidth);specWidth=specWidth'; disp(5); end
            %            error(' ')
            %            save('testing.mat','self','dataRows','orderProfile','varProfile','specCenters','specWidth','RN')
            
            phi=self.getPhi(dataRows,specCenters,2*log(2)*specWidth,[ones(length(specCenters),1)]);
            
            [xout,~,~,~] = fminsearch(@optimizeBackgroundFit, polyfit(dataRows,orderProfile/sum(orderProfile),1));
            
            [chi2, fittedValues, fittedErrors, M]=optimizeBackgroundFit(xout);
            
            spectraValues=fittedValues(1:end-1);
            spectraErrors=fittedErrors(1:end-1);
            background=fittedValues(end)*polyval(xout,dataRows)/sum(polyval(xout,dataRows));
            
            function [chi2, fittedValues, fittedErrors, M]=optimizeBackgroundFit(x)
                %setup
                phifit=[phi; polyval(x,dataRows)/sum(polyval(x,dataRows))];%ones(1,size(phi,2))/size(phi,2) %([1:size(phi,2)]*x(1)+x(2)) / sum([1:size(phi,2)]*x(1)+x(2))
                sigmaweightedPhi=bsxfun(@rdivide,phifit,sqrt(varProfile))';
                c=phifit*sigmaweightedPhi;
                b=((orderProfile)*sigmaweightedPhi)';
                
                %setup error
                ce=phifit*phifit';
                be=((varProfile-RN^2)*phifit')';
                
                %solve
                fittedValues=c\b;
                fittedErrors=ce\be;
                
                %Model
                M=sum(bsxfun(@times,phifit,fittedValues),1);
                
                chi2=sum(((orderProfile-M)).^2./varProfile)/(size(M,2)-size(fittedValues,1)-length(x));
                %                 if chi2>1
                %                     plot(1:195,M,1:195,orderProfile)
                %                     drawnow;
                %                 end
            end
        end
        
        function [spectraValues, spectraErrors, background]=MPDoptimalExt(self,dataRows,orderProfile,varProfile,specCenters,specWidth,RN)
            % Multi-Profile Deconvolution Optimal Extraction as described by Sharp & Birchall (2010)
            %
            % paper: Sharp R., Birchall M. N. (2010) Optimal Extraction of Fibre Optic Spectroscopy. PASA 27, pp. 91-103.
            %        http://dx.doi.org/10.1071/AS08001
            
            %setup
            %             if 0
            %                 phi=self.getPhi(dataRows,specCenters,specWidth,ones(length(specCenters),1));
            %             %%phi
            %             else
            %             phi1=;
            %             phi2=;
            %             phi3=
            spectraValues=zeros(size(specCenters'));
            spectraErrors=spectraValues;
            for col=1:size(specCenters,1)
                phi=bsxfun(@times, exp(-(bsxfun(@rdivide, bsxfun(@minus,repmat(dataRows{col},...
                    [size(specCenters,2),1]),specCenters(col,:)'), specWidth(col,:)')).^2), 1./(specWidth(col,:)'*sqrt(pi)));
                %phi=bsxfun(@times, phi4, specPeaks);
                %phi=sparse(phi);
                phi(phi<1e-6)=0;
                %             end
                
                %            if 1
                sigmaweightedPhi=bsxfun(@rdivide,phi,sqrt(varProfile{col}))';
                c=phi*sigmaweightedPhi;
                b=((orderProfile{col})*sigmaweightedPhi)';
                %             else
                %                 sigmaweightedPhi=bsxfun(@rdivide,phi,sqrt(varProfile))';
                %                 c=mtimesx(phi,sigmaweightedPhi,'MATLAB');
                %                 b=mtimesx(orderProfile,sigmaweightedPhi,'MATLAB')';
                %             end
                
                %setup error
                ce=phi*phi';
                be=((varProfile{col}-RN^2)*phi')';
                
                %solve
                spectraValues(:,col)=(c\b);
                %spectraValues=linsolve(c,b);
                spectraErrors(:,col)=(ce\be);
                %spectraErrors=linsolve(ce,be);
                
            end
            background=cellfun(@(x) zeros(size(x)),orderProfile,'UniformOutput',false);
            
        end
        
        function [spectraValues, spectraErrors, background]=MPDoptimalExtOld(self,dataRows,orderProfile,varProfile,specCenters,specWidth,RN)
            % Multi-Profile Deconvolution Optimal Extraction as described by Sharp & Birchall (2010)
            %
            % paper: Sharp R., Birchall M. N. (2010) Optimal Extraction of Fibre Optic Spectroscopy. PASA 27, pp. 91-103.
            %        http://dx.doi.org/10.1071/AS08001
            
            %setup
            %             if 0
            %                 phi=self.getPhi(dataRows,specCenters,specWidth,ones(length(specCenters),1));
            %             %%phi
            %             else
            phi1=bsxfun(@minus,repmat(dataRows,[length(specCenters),1]),specCenters);
            phi2=bsxfun(@rdivide, phi1, specWidth);
            phi3=exp(-(phi2).^2);
            phi=bsxfun(@times, phi3, 1./(specWidth*sqrt(pi)));
            %phi=bsxfun(@times, phi4, specPeaks);
            %phi=sparse(phi);
            phi(phi<1e-8)=0;
            %             end
            
            %            if 1
            sigmaweightedPhi=bsxfun(@rdivide,phi,sqrt(varProfile))';
            c=phi*sigmaweightedPhi;
            b=((orderProfile)*sigmaweightedPhi)';
            %             else
            %                 sigmaweightedPhi=bsxfun(@rdivide,phi,sqrt(varProfile))';
            %                 c=mtimesx(phi,sigmaweightedPhi,'MATLAB');
            %                 b=mtimesx(orderProfile,sigmaweightedPhi,'MATLAB')';
            %             end
            
            %setup error
            ce=phi*phi';
            be=((varProfile-RN^2)*phi')';
            
            %solve
            spectraValues=(c\b);
            %spectraValues=linsolve(c,b);
            spectraErrors=(ce\be);
            %spectraErrors=linsolve(ce,be);
            background=zeros(size(orderProfile));
            
        end
        
        function phi=getPhi(~,dataRows,specCenters,specWidth,specPeaks)
            phi1=bsxfun(@minus,repmat(dataRows,[length(specCenters),1]),specCenters);
            phi2=bsxfun(@rdivide, phi1, specWidth);
            phi3=exp(-(phi2).^2);
            phi4=bsxfun(@times, phi3, 1./(specWidth*sqrt(pi)));
            phi=bsxfun(@times, phi4, specPeaks);
            %phi=sparse(phi);
            phi(phi<1e-8)=0;
        end
        
        function lineariseAndCombineSpectrum(self,saveFiles)
            
            if nargin==1
                saveFiles=false;
            end
            
            spec=(self.spectraValues);%./self.P2PVariationValues;%./self.flatBlaze;%
            specVar=(self.spectraVar);%./self.P2PVariationValues;%./self.flatBlaze;%
            
            %             for or=1:self.numOfOrders
            %                 specVar(:,:,or) = bsxfun(@rdivide,specVar(:,:,or),max(spec(:,:,or)')');
            %                 spec(:,:,or)    = bsxfun(@rdivide,spec(:,:,or),max(spec(:,:,or)')');
            %             end
            
            longwavelinear=linspace(min(self.wavefit(:)),max(self.wavefit(:)),self.imdim(2)*self.numOfOrders);
            
            speclinearlong=zeros(self.numOfFibers,self.imdim(2)*self.numOfOrders,self.numOfOrders);
            spectraVarlinearlong=zeros(self.numOfFibers,self.imdim(2)*self.numOfOrders,self.numOfOrders);
            
            for o=1:self.numOfOrders
                for f=1:size(spec,1);
                    speclinearlong(f,:,o)=interp1(self.wavefit(f,:,o),spec(f,:,o),longwavelinear,'spline',0);
                    spectraVarlinearlong(f,:,o)=interp1(self.wavefit(f,:,o),specVar(f,:,o),longwavelinear,'spline',0);
                    specflatlong(f,:,o)=interp1(self.wavefit(f,:,o),self.flatBlaze(f,:,o),longwavelinear,'spline',0);
                end
            end
            %specflatlong=ones(size(speclinearlong));
            
            finalspeclong=nansum(speclinearlong,3)';%./nansum(specflatlong,3)';
            finalspecVarlong=nansum(spectraVarlinearlong,3)';%./nansum(specflatlong,3)';
            flatspeclong=nansum(specflatlong,3)';
            
            finalspeclong=finalspeclong./bsxfun(@rdivide,flatspeclong,mean(flatspeclong));
            finalspecVarlong=finalspecVarlong./bsxfun(@rdivide,flatspeclong,mean(flatspeclong));
            
            toclip=isnan(sum(finalspeclong,2));
            
            longwavelinear_clipped=longwavelinear(~toclip);
            finalspecVarlong_clipped=finalspecVarlong(~toclip,:);
            finalspeclong_clipped=finalspeclong(~toclip,:);
            
            self.finalSpectra=squeeze(finalspeclong_clipped');
            self.finalSpectraVar=squeeze(finalspecVarlong_clipped');
            self.finalWave=longwavelinear_clipped;
            
            self.finalSpec=squeeze(sum(finalspeclong_clipped,2)');
            self.finalSpecVar=squeeze(sum(finalspecVarlong_clipped,2)');
            
            if 0
                %%
                for i=1:size(finalspecVarlong_clipped,2)
                    smoother(:,i)=csaps(self.finalWave,finalspecVarlong_clipped(:,i),0.0000001,self.finalWave);
                end
                %%
                smoother=mean(smoother,2)';
                %[smoother] = blazeCorrection(self.finalSpec,self.finalWave,0.98)';
            else
                smoother=1;
            end
            %            error(' ')
            self.finalSpec=self.finalSpec./smoother;
            self.finalSpecVar=self.finalSpecVar./smoother;
            
            if saveFiles
                header=self.targetHeader;
                header.IMAGETYP='SPECTRUM';
                header.CRPIX1=round(length(self.finalWave)/2);
                header.CRVAL1=self.finalWave(header.CRPIX1);
                header.CTYPE1='Wavelength';
                header.CUNIT1='nm';
                header.CDELT1=mean(diff(self.finalWave));
                header.UTC=round((header.JD-floor(header.JD))*24*60*60);
                header.MJD=header.JD-2400000.5;
                header.DLAT=-33.873651000000000000;
                header.DLONG=151.206889600000070000;%sydney
                header.GEOELV=100;
                
                headercell1=fitstructure2cell(header);
                
                header2.EXTNAME='FLUXERROR';
                headercell2=fitstructure2cell(header2);
                
                fitswrite(finalspeclong_clipped,[self.targetBaseFilename '-IndivCalSpec.fit'],'keywords',headercell1(8:end,:))
                fitswrite(finalspecVarlong_clipped,[self.targetBaseFilename '-IndivCalSpec.fit'],'writemode','append','keywords',headercell2)
                
                fitswrite(self.finalSpec,[self.targetBaseFilename '-CombCalSpec.fit'],'keywords',headercell1(8:end,:))
                fitswrite(self.finalSpecVar,[self.targetBaseFilename '-CombCalSpec.fit'],'writemode','append','keywords',headercell2)
            end
        end
    end
    
    methods (Static, Access = private)
        function answer=checkForReducedFitsAt(path)
            % check for a reduced target
            try
                import matlab.io.*
                fptr = fits.openFile(path);
                fits.closeFile(fptr);
                answer=1;
            catch err
                if strcmp(err.identifier,'MATLAB:imagesci:fits:libraryError')
                    error('MISPRINT:checkForReducedTarget:fitsOpenError','Reduced fits file does not exist.')
                else
                    rethrow(err)
                end
            end
        end
    end
    methods (Static)
        [specCenters, p, mu]=polyfitwork(imdim,means,column,polyorder,offset,plotalot)
        prepareFrames
        [peaks,means,widths,xfitted] = fitNGaussainsAlt(N,x,y,peakcut,plotting)
        out=nGausFunc(x,xData,N)
        wavecalGUI
        autoimprovewavelength(varargin)
    end
end
##### SOURCE END #####
--></body></html>